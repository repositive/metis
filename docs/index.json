[
  {
    "__docId__": 1,
    "kind": "external",
    "name": "Infinity",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Infinity",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Infinity",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 2,
    "kind": "external",
    "name": "NaN",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NaN",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~NaN",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 3,
    "kind": "external",
    "name": "undefined",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~undefined",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 4,
    "kind": "external",
    "name": "null",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/null",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~null",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 5,
    "kind": "external",
    "name": "Object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Object",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 6,
    "kind": "external",
    "name": "object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~object",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 7,
    "kind": "external",
    "name": "Function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Function",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 8,
    "kind": "external",
    "name": "function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~function",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 9,
    "kind": "external",
    "name": "Boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Boolean",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 10,
    "kind": "external",
    "name": "boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~boolean",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 11,
    "kind": "external",
    "name": "Symbol",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Symbol",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 12,
    "kind": "external",
    "name": "Error",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Error",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 13,
    "kind": "external",
    "name": "EvalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/EvalError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~EvalError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 14,
    "kind": "external",
    "name": "InternalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/InternalError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~InternalError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 15,
    "kind": "external",
    "name": "RangeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RangeError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~RangeError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 16,
    "kind": "external",
    "name": "ReferenceError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ReferenceError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~ReferenceError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 17,
    "kind": "external",
    "name": "SyntaxError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SyntaxError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~SyntaxError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 18,
    "kind": "external",
    "name": "TypeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~TypeError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 19,
    "kind": "external",
    "name": "URIError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/URIError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~URIError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 20,
    "kind": "external",
    "name": "Number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Number",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 21,
    "kind": "external",
    "name": "number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~number",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 22,
    "kind": "external",
    "name": "Date",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Date",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 23,
    "kind": "external",
    "name": "String",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~String",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 24,
    "kind": "external",
    "name": "string",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~string",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 25,
    "kind": "external",
    "name": "RegExp",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~RegExp",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 26,
    "kind": "external",
    "name": "Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 27,
    "kind": "external",
    "name": "Int8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int8Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Int8Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 28,
    "kind": "external",
    "name": "Uint8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint8Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 29,
    "kind": "external",
    "name": "Uint8ClampedArray",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8ClampedArray",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint8ClampedArray",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 30,
    "kind": "external",
    "name": "Int16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int16Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Int16Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 31,
    "kind": "external",
    "name": "Uint16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint16Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint16Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 32,
    "kind": "external",
    "name": "Int32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int32Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Int32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 33,
    "kind": "external",
    "name": "Uint32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 34,
    "kind": "external",
    "name": "Float32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Float32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 35,
    "kind": "external",
    "name": "Float64Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float64Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Float64Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 36,
    "kind": "external",
    "name": "Map",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Map",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 37,
    "kind": "external",
    "name": "Set",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Set",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 38,
    "kind": "external",
    "name": "WeakMap",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~WeakMap",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 39,
    "kind": "external",
    "name": "WeakSet",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakSet",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~WeakSet",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 40,
    "kind": "external",
    "name": "ArrayBuffer",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~ArrayBuffer",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 41,
    "kind": "external",
    "name": "DataView",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~DataView",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 42,
    "kind": "external",
    "name": "JSON",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~JSON",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 43,
    "kind": "external",
    "name": "Promise",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Promise",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 44,
    "kind": "external",
    "name": "Generator",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Generator",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 45,
    "kind": "external",
    "name": "GeneratorFunction",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/GeneratorFunction",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~GeneratorFunction",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 46,
    "kind": "external",
    "name": "Reflect",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Reflect",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 47,
    "kind": "external",
    "name": "Proxy",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Proxy",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 48,
    "kind": "file",
    "name": "src/Annotation/annotate-schema.spec.ts",
    "content": "import * as test from 'tape';\nimport { Test } from 'tape';\nimport * as Ajv from 'ajv';\nimport * as fs from 'fs';\n\n//--------------------------\n\nconst schemas: any[] = [\n  JSON.parse(fs.readFileSync('./schemas/get-schema.json', 'utf8'))\n];\n\nconst ajv = new Ajv({ allErrors: true, verbose: true, schemas });\n\ntest('The schemas are valid', (t: Test) => {\n  schemas.forEach((item) => {\n    const schema = ajv.getSchema(item.id);\n    t.ok(schema !== undefined, `Schema ${item.id} loads`);\n  });\n  t.end();\n});\n\ntest('Term is required for get function', (t: Test) => {\n  const schema = ajv.getSchema('get-schema.json');\n  const json = { field: 'abc' };\n  const valid = schema(json);\n  t.notOk(valid, 'Object without term is not valid payload');\n  t.ok(schema.errors, `There are errors in ingestion-schema.json`);\n  if (schema.errors) {\n    t.equals(schema.errors[0]['message'], 'should have required property \\'term\\'', 'Correct error message');\n  }\n  t.end();\n});\n\n",
    "static": true,
    "longname": "/Users/alexanderbrinkmann/Documents/Repositories/metis/src/Annotation/annotate-schema.spec.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 49,
    "kind": "variable",
    "name": "schemas",
    "memberof": "src/Annotation/annotate-schema.spec.ts",
    "static": true,
    "longname": "src/Annotation/annotate-schema.spec.ts~schemas",
    "access": "public",
    "export": false,
    "importPath": "metis/src/Annotation/annotate-schema.spec.ts",
    "importStyle": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "type": {
      "types": [
        "undefined[]"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 50,
    "kind": "variable",
    "name": "ajv",
    "memberof": "src/Annotation/annotate-schema.spec.ts",
    "static": true,
    "longname": "src/Annotation/annotate-schema.spec.ts~ajv",
    "access": "public",
    "export": false,
    "importPath": "metis/src/Annotation/annotate-schema.spec.ts",
    "importStyle": null,
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 51,
    "kind": "file",
    "name": "src/Annotation/annotate.spec.ts",
    "content": "import * as test from 'tape';\nimport { Test } from 'tape';\nimport { stub } from 'sinon';\nimport * as proxyquire from 'proxyquire';\nimport * as fs from 'fs';\n\n//-------------------------------\n\ntest('Testing Zooma annotate service', (t: Test) => {\n  t.test('The term is successfully matched', async function (st: Test) {\n\n    const field = 'assay';\n    const term = 'WXS';\n\n    const annotateResult = [{\n      term: 'random exon sequencing',\n      iri: 'http://www.ebi.ac.uk/efo/EFO_0003746',\n      confidence: 0.6,\n      source: 'http://www.ebi.ac.uk/efo/efo.owl',\n      short_name: 'efo'\n    }];\n\n    const requestResponse: any = JSON.parse(fs.readFileSync('./assets/testAnnotateResponse.json', 'utf8'));\n\n    const mockedReq = stub().returns(Promise.resolve([requestResponse]));\n\n    const _annotate = proxyquire('./annotate', {\n      'request-promise': mockedReq\n    });\n\n    st.equals(typeof _annotate.default, 'function', 'The module exports a function called annotate');\n\n    const result = await _annotate.default({ payload: { field, term } })\n      .then(function (data: any) {\n        //console.log('got data', data);\n        return data;\n      }).catch((err: any) => {\n        console.error(err);\n        console.log('annotate error');\n        // API call failed...\n        st.notOk(err, 'There is an error');\n      });\n\n    st.assert(mockedReq.called, 'It calls request');\n    st.equal(mockedReq.callCount, 1, 'It calls request once');\n    st.assert(result instanceof Object, 'Returns an object');\n    st.assert(('term' in result[0]), 'Result has ontologyTerm');\n    st.deepEquals(result, annotateResult, 'The final result is equal to the expected result');\n    st.end();\n\n  });\n\n  t.test('The shortname is the accession prefix', async function (st: Test) {\n\n    const field = 'disease';\n    const term = 'abc';\n\n    const annotateResult = [{\n      term: 'abc disease',\n      iri: 'http://www.test.net/abc/ABCDE_166',\n      confidence: 0.8,\n      source: 'https://www.test',\n      short_name: 'abcde'\n    }];\n\n    const requestResponse: any = {\n      'annotatedProperty': { 'propertyValue': 'abc disease' },\n      '_links': { 'olslinks': [{ 'semanticTag': 'http://www.test.net/abc/ABCDE_166' }] },\n      'derivedFrom': { 'provenance': { 'source': { 'uri': 'https://www.test' } } },\n      'confidence': 0.8\n    };\n\n    const mockedReq = stub().returns(Promise.resolve([requestResponse]));\n    const _annotate = proxyquire('./annotate', { 'request-promise': mockedReq });\n\n    const result = await _annotate.default({ payload: { field, term } })\n      .then(function (data: any) {\n        return data;\n      }).catch((err: any) => {\n        console.error(err);\n      });\n\n    st.assert(typeof result[0].short_name === 'string', 'Ontology shortname is a string');\n    st.deepEquals(result[0].short_name, annotateResult[0].short_name, 'The shortname is equal to the accession prefix');\n    st.end();\n  });\n\n  t.test('The shortname is correct when the accession prefix is unusual', async function (st: Test) {\n\n    const field = 'disease';\n    const term = 'abc';\n\n    const annotateResult = [{\n      term: 'abc disease',\n      iri: 'http://www.test.net/abc/topic_166',\n      confidence: 0.8,\n      source: 'https://www.test',\n      short_name: 'edam'\n    }];\n\n    const requestResponse: any = {\n      'annotatedProperty': { 'propertyValue': 'abc disease' },\n      '_links': { 'olslinks': [{ 'semanticTag': 'http://www.test.net/abc/topic_166' }] },\n      'derivedFrom': { 'provenance': { 'source': { 'uri': 'https://www.test' } } },\n      'confidence': 0.8\n    };\n\n    const mockedReq = stub().returns(Promise.resolve([requestResponse]));\n    const _annotate = proxyquire('./annotate', { 'request-promise': mockedReq });\n\n    const result = await _annotate.default({ payload: { field, term } })\n      .then(function (data: any) {\n        return data;\n      }).catch((err: any) => {\n        console.error(err);\n      });\n\n    st.assert(typeof result[0].short_name === 'string', 'Ontology shortname is a string');\n    st.deepEquals(result[0].short_name, annotateResult[0].short_name, 'The shortname is correct');\n    st.end();\n  });\n\n  t.test('The shortname is correct when the accession prefix is Orphanet', async function (st: Test) {\n\n    const field = 'disease';\n    const term = 'abc';\n\n    const annotateResult = [{\n      term: 'abc disease',\n      iri: 'http://www.test.net/abc/Orphanet_166',\n      confidence: 0.8,\n      source: 'https://www.test',\n      short_name: 'ordo'\n    }];\n\n    const requestResponse: any = {\n      'annotatedProperty': { 'propertyValue': 'abc disease' },\n      '_links': { 'olslinks': [{ 'semanticTag': 'http://www.test.net/abc/Orphanet_166' }] },\n      'derivedFrom': { 'provenance': { 'source': { 'uri': 'https://www.test' } } },\n      'confidence': 0.8\n    };\n\n    const mockedReq = stub().returns(Promise.resolve([requestResponse]));\n    const _annotate = proxyquire('./annotate', { 'request-promise': mockedReq });\n\n    const result = await _annotate.default({ payload: { field, term } })\n      .then(function (data: any) {\n        return data;\n      }).catch((err: any) => {\n        console.error(err);\n      });\n\n    st.assert(typeof result[0].short_name === 'string', 'Ontology shortname is a string');\n    st.deepEquals(result[0].short_name, annotateResult[0].short_name, 'The shortname is correct');\n    st.end();\n  });\n\n  t.test('An unknown term is not matched', async function (st: Test) {\n\n    const field = 'tissue';\n    const term = 'viiat';\n\n    const annotateResult: any[] = [];\n    const requestResponse = undefined;\n\n    const mockedReq = stub().returns(Promise.resolve([requestResponse]));\n    const _annotate = proxyquire('./annotate', {\n      'request-promise': mockedReq\n    });\n\n    st.equals(typeof _annotate.default, 'function', 'The module exports a function called annotate');\n\n    const result = await _annotate.default({ payload: { field, term } })\n      .then(function (data: any) {\n        //console.log('got data', data);\n        return data;\n      }).catch((err: any) => {\n        console.error(err);\n        console.log('annotate error - API call failed...');\n        st.notOk(err, 'There is an error');\n      });\n\n    st.ok(mockedReq.called, 'It calls request');\n    st.equal(mockedReq.callCount, 1, 'It calls request once');\n    st.assert(Array.isArray(result) && result.length === 0, 'Returns an empty array');\n    st.deepEquals(result, annotateResult, 'The final result is equal to the expected result');\n    st.end();\n  });\n\n  t.test('If term is \\'undefined\\' there is an error', async function (st: Test) {\n\n    const field = 'tissue';\n    const term = undefined;\n    const annotateResult: any[] = [];\n    const requestResponse = {};\n\n    const mockedReq = stub().returns(Promise.resolve([requestResponse]));\n    const _annotate = proxyquire('./annotate', {\n      'request-promise': mockedReq\n    });\n\n    st.equals(typeof _annotate.default, 'function', 'The module exports a function called annotate');\n\n    const result = await _annotate.default({ payload: { field, term } })\n      .then(function (data: any) {\n        return data;\n      }).catch((err: any) => {\n        st.ok(err, 'There is an error');\n      });\n\n    st.ok(mockedReq.notCalled, 'It doesn\\'t call request function');\n    st.deepEquals(result, annotateResult, 'Returns an empty array');\n    st.end();\n  });\n\n  t.test('If term is \\'none\\' there is no error and no matching', async function (st: Test) {\n\n    const field = 'tissue';\n    const term = 'none';\n    const annotateResult: any[] = [];\n    const requestResponse = {};\n\n    const mockedReq = stub().returns(Promise.resolve([requestResponse]));\n    const _annotate = proxyquire('./annotate', {\n      'request-promise': mockedReq\n    });\n\n    st.equals(typeof _annotate.default, 'function', 'The module exports a function called annotate');\n\n    const result = await _annotate.default({ payload: { field, term } })\n      .then(function (data: any) {\n        //console.log('got data', data);\n        return data;\n      }).catch((err: any) => {\n        console.error(err);\n        console.log('annotate error');\n        // API call failed...\n        st.notOk(err, 'There is an error');\n      });\n\n    st.ok(mockedReq.notCalled, 'It doesn\\'t call request function');\n    st.assert(Array.isArray(result) && result.length === 0, 'Returns an empty array');\n    st.deepEquals(result, annotateResult, 'The final result is equal to the expected result');\n    st.end();\n  });\n\n  t.test('Request errors throw a new error', async function (st: Test) {\n\n    const field = 'tissue';\n    const term = 'abc';\n\n    const mockedReq = stub().returns(Promise.reject(new Error('fail')));\n\n    const _annotate = proxyquire('./annotate', {\n      'request-promise': mockedReq\n    });\n\n    const result = await _annotate.default({ payload: { field, term } })\n      .then(function (data: any) {\n        return data;\n      }).catch((err: any) => {\n        st.assert(err, 'There is an error from the request');\n      });\n    st.end();\n  });\n\n  t.end();\n});\n",
    "static": true,
    "longname": "/Users/alexanderbrinkmann/Documents/Repositories/metis/src/Annotation/annotate.spec.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 52,
    "kind": "file",
    "name": "src/Annotation/annotate.ts",
    "content": "import * as request from 'request-promise';\nimport * as Ajv from 'ajv';\nimport * as R from 'ramda';\n\n//-----------------------\n\nconst confidenceScoreF = (text: string) => R.cond([\n  [R.equals('LOW'), R.always(0.2)],\n  [R.equals('MEDIUM'), R.always(0.4)],\n  [R.equals('GOOD'), R.always(0.6)],\n  [R.equals('HIGH'), R.always(0.8)],\n  [R.T, R.always(1)]\n])(text);\n\nexport default async function annotate({\n   payload,\n  _request = request,\n  _confidenceScoreF = confidenceScoreF\n  }: {\n    payload: { field: string, term: string },\n    _request?: typeof request,\n    _confidenceScoreF?: typeof confidenceScoreF\n  }): Promise<any> {\n\n  const { field, term } = payload;\n\n  const ontologyDict = {\n    'assay': 'efo,edam',\n    'technology': 'efo,edam',\n    'disease': 'efo,hp',\n    'tissue': 'efo,hp'\n  };\n\n  const ontology = ontologyDict[field];\n\n  const excludedTerms = ['n/a', 'na', 'none', 'not available', 'not specified', 'other', 'unavailable', 'unknown', 'unspecified'];\n\n  if (!term || excludedTerms.indexOf(term.toLowerCase()) > -1) {\n    return []; // if term is excluded return undefined\n  }\n\n  const options = {\n    method: 'GET',\n    uri: 'http://www.ebi.ac.uk/spot/zooma/v2/api/services/annotate',\n    qs: {\n      propertyValue: term.toLowerCase(),\n      filter: `required:[gxa],ontologies:[${ontology}]`\n    },\n    json: true\n  };\n\n  const json: any = await _request(options)\n    .then((res: any) => {\n      return res;\n    })\n    .catch((err: any) => {\n      throw new Error('_request error: ' + err);\n    });\n\n  // if there is no match, the request returns [undefined]\n  // if there are multiple matches, returns all.\n\n  if (json.length > 0 && typeof json[0] !== 'undefined') {\n    return json.map((x: any) => {\n      const uriSplit = x._links.olslinks[0].semanticTag.split('/');\n\n      // make ontologyShortName equal to ontology accession prefix\n      let short_name = uriSplit.slice(-1)[0].split('_')[0].toLowerCase();\n      if (['format', 'operation', 'topic', 'data'].indexOf(short_name) > -1) short_name = 'edam';\n      if (short_name === 'orphanet') short_name = 'ordo';\n\n      return {\n        term: x.annotatedProperty.propertyValue.toLowerCase(),\n        iri: x._links.olslinks[0].semanticTag,\n        confidence: _confidenceScoreF(x.confidence),\n\n        //  also storing which ontology it comes from\n        source: x.derivedFrom.provenance.source.uri,\n        short_name // shortname from IRI\n      };\n    });\n\n  } else {\n    return []; // if there is no match, returns an empty array\n  }\n}\n",
    "static": true,
    "longname": "/Users/alexanderbrinkmann/Documents/Repositories/metis/src/Annotation/annotate.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 53,
    "kind": "function",
    "name": "confidenceScoreF",
    "memberof": "src/Annotation/annotate.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Annotation/annotate.ts~confidenceScoreF",
    "access": "public",
    "export": false,
    "importPath": "metis/src/Annotation/annotate.ts",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "params": [
      {
        "name": "text",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 54,
    "kind": "function",
    "name": "annotate",
    "memberof": "src/Annotation/annotate.ts",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "src/Annotation/annotate.ts~annotate",
    "access": "public",
    "export": true,
    "importPath": "metis/src/Annotation/annotate.ts",
    "importStyle": "annotate",
    "description": "",
    "lineNumber": 15,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "undefined",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 55,
    "kind": "file",
    "name": "src/Annotation/controllerAnnotate.spec.ts",
    "content": "import * as test from 'tape';\nimport { Test } from 'tape';\nimport { stub } from 'sinon';\n\nimport * as fs from 'fs';\nimport * as Ajv from 'ajv';\n\nimport { get, selectFromDb, getAnnotation } from './controllerAnnotate';\n\n//-------------------------------\n\ntest('Testing Annotation controller', (t: Test) => {\n  t.test('Test get function when term is in database', async function (st: Test) {\n\n    const _postgres: any = {};\n    const payload = { field: 'abc', term: 'test' };\n    const _ajv: any = new Ajv();\n    const validateStub = stub(_ajv, 'validate').returns(true);\n    const _schema = stub();\n    const mockResult = [{\n      'ontology_uid': 26,\n      'confidence': 0.6,\n      'ontology_uri': 'http://www.test.ac.uk/TEST_0005016',\n      'ontology_term': 'test',\n      'source_uri': 'https://www.test.ac.uk/test',\n      'short_name': 'test'\n    }];\n    const _selectFromDb = stub().returns(Promise.resolve(mockResult));\n    const _getAnnotation = stub().returns(Promise.resolve());\n\n    const result = await get({ payload, _postgres, _ajv, _getAnnotation, _schema, _selectFromDb })\n      .catch((err) => {\n        st.notOk(err, 'Function should not error');\n      });\n\n    st.assert((_ajv.validate as any).called, 'It calls validate once');\n    st.assert((_selectFromDb as any).calledOnce, 'It calls _selectFromDb');\n    st.equals(_selectFromDb.getCall(0).args[0]._term, 'test', 'SelectFromDb is called with the correct term');\n    st.deepEquals(result, mockResult, 'It returns the expected result');\n    st.end();\n\n  });\n\n  t.test('If the schema is not valid, throws an error', async function (st: Test) {\n\n    const _postgres: any = {};\n    const payload = { field: 'abc', term: 'test' };\n    const _ajv: any = new Ajv();\n    const validateStub = stub(_ajv, 'validate').returns(false);\n    const _schema: any = JSON.parse(fs.readFileSync('./schemas/get-schema.json', 'utf8'));\n    const mockResult = {\n      'ontology_uid': 26,\n      'confidence': 0.6,\n      'ontology_uri': 'http://www.test.ac.uk/TEST_0005016',\n      'ontology_term': 'test',\n      'source_uri': 'https://www.test.ac.uk/test',\n      'short_name': 'test'\n    };\n    const _selectFromDb = stub().returns(Promise.resolve(mockResult));\n    const _getAnnotation = stub().returns(Promise.resolve());\n\n    const result = await get({ payload, _postgres, _ajv, _getAnnotation, _schema, _selectFromDb })\n      .catch((err) => {\n        st.ok(err, 'Function should throw error');\n      });\n\n    st.assert((_ajv.validate as any).calledOnce, 'It calls validate once');\n    st.deepEquals((_ajv.validate as any).getCall(0).args, [_schema, payload], 'It calls validate with correct args');\n    st.assert(_selectFromDb.notCalled, 'SelectFromDb is not called');\n    st.end();\n\n  });\n\n  t.test('Test get function when term is not in database', async function (st: Test) {\n\n    const _postgres: any = {};\n    const payload = { field: 'abc', term: 'test' };\n    const _ajv: any = new Ajv();\n    const validateStub = stub(_ajv, 'validate').returns(true);\n    const _schema = stub();\n    const mockResult = [{\n      'ontology_uid': 26,\n      'confidence': 0.6,\n      'ontology_uri': 'http://www.test.ac.uk/TEST_0005016',\n      'ontology_term': 'test',\n      'source_uri': 'https://www.test.ac.uk/test',\n      'short_name': 'test'\n    }];\n    const _selectFromDb = stub()\n      .onFirstCall().returns(Promise.resolve([undefined]))\n      .onSecondCall().returns(Promise.resolve(mockResult));\n    const _getAnnotation = stub().returns(Promise.resolve());\n\n    const result = await get({ payload, _postgres, _ajv, _getAnnotation, _schema, _selectFromDb })\n      .catch((err) => {\n        st.notOk(err, 'Function should not error');\n      });\n\n    st.assert(_selectFromDb.calledTwice, 'It calls selectFromDb twice');\n    st.equals(_selectFromDb.getCall(0).args[0]._term, 'test', 'selectFromDb is called with the correct term');\n    st.deepEquals(_getAnnotation.getCall(0).args[0].payload, payload, 'getAnnotation is called with the correct payload');\n    st.equals(_selectFromDb.getCall(1).args[0]._term, 'test', 'selectFromDb is called again with the correct term');\n    st.equals(result, mockResult, 'It returns the expected result');\n    st.end();\n  });\n\n  t.test('Test selectFromDb', async function (st: Test) {\n\n    const mockResult = {\n      otherKey: 'other',\n      rows: [{\n        'ontology_uid': 26,\n        'confidence': 0.6,\n        'ontology_uri': 'http://www.test.ac.uk/TEST_0005016',\n        'ontology_term': 'test',\n        'source_uri': 'https://www.test.ac.uk/test',\n        'short_name': 'test'\n      }]\n    };\n\n    const expectedResult = [{\n      'ontology_uid': 26,\n      'confidence': 0.6,\n      'ontology_uri': 'http://www.test.ac.uk/TEST_0005016',\n      'ontology_term': 'test',\n      'source_uri': 'https://www.test.ac.uk/test',\n      'short_name': 'test'\n    }];\n\n    const _postgres: any = { query: stub().returns(Promise.resolve(mockResult)) };\n    const _term = 'test';\n    const result = await selectFromDb({ _postgres, _term })\n      .catch((err) => {\n        st.notOk(err, 'Function should not error');\n      });\n\n    st.assert((_postgres.query as any).calledOnce, 'Query postgres once');\n    st.deepEquals(result, expectedResult, 'It returns the expected result');\n    st.end();\n  });\n\n  t.test('Test getAnnotation', async function (st: Test) {\n\n    const mockResultArray = [{\n      term: 'test',\n      iri: 'http://www.test.ac.uk/TEST_0005016',\n      confidence: 0.75,\n      source: 'https://www.test.ac.uk/test',\n      short_name: 'test'\n    }];\n\n    const mockResultObj = mockResultArray[0];\n    const mockOntology_uid = 5;\n\n    const query = stub()\n      .onFirstCall().returns(Promise.resolve({ rows: [{ id: mockOntology_uid }] }))\n      .onSecondCall().returns(Promise.resolve(mockResultObj));\n\n    const _postgres: any = { query };\n    const payload = { field: 'abc', term: 'test' };\n    const _annotate = stub().returns(Promise.resolve(mockResultArray));\n\n    const result = await getAnnotation({ payload, _postgres, _annotate })\n      .catch((err) => {\n        st.notOk(err, 'Function should not error');\n      });\n\n    st.equals((_annotate as any).getCall(0).args[0].payload, payload, 'Calls annotate with correct payload');\n    st.equals((_postgres.query as any).callCount, 2, 'Postgres query called correct number of times');\n\n    st.deepEquals((_postgres.query as any).getCall(0).args[0].values, [mockResultObj.iri, mockResultObj.term, mockResultObj.source, mockResultObj.short_name], 'First query made inserts ontology term');\n    st.deepEquals((_postgres.query as any).getCall(1).args[0].values, [payload.term, mockOntology_uid, mockResultObj.confidence], 'Second query is to insert the original term');\n    st.end();\n  });\n\n  t.end();\n});\n",
    "static": true,
    "longname": "/Users/alexanderbrinkmann/Documents/Repositories/metis/src/Annotation/controllerAnnotate.spec.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 56,
    "kind": "file",
    "name": "src/Annotation/controllerAnnotate.ts",
    "content": "import { Pool } from 'pg';\nimport annotate from './annotate';\nimport * as fs from 'fs';\nimport * as Ajv from 'ajv';\nconst ajv = new Ajv({ allErrors: true, verbose: true });\n\n// --------------------------\n\nconst schema: any = JSON.parse(fs.readFileSync('./schemas/get-schema.json', 'utf8'));\n\nexport interface GetOntologyInput {\n  term: string;\n  field?: string;\n  force?: boolean;\n}\n\nexport async function get({\n  payload,\n  _postgres,\n  _selectFromDb = selectFromDb,\n  _getAnnotation = getAnnotation,\n  _ajv = ajv,\n  _schema = schema\n }: {\n    payload: GetOntologyInput,\n    _postgres: Pool,\n    _selectFromDb?: typeof selectFromDb,\n    _getAnnotation?: typeof getAnnotation,\n    _ajv?: typeof ajv,\n    _schema?: typeof schema\n  }): Promise<any[]> {\n\n  const valid = _ajv.validate(_schema, payload);\n  if (!valid) {\n    console.log(_ajv.errors);\n    throw new Error('Payload schema error');\n  }\n\n  let result = await _selectFromDb({ _postgres, _term: payload.term });\n\n  // if result undefined (ie. no rows found)\n  if (result[0] === undefined && payload.field) {\n    const { field, term } = payload;\n    const stored = await _getAnnotation({ payload: { field, term }, _postgres });\n    result = await _selectFromDb({ _postgres, _term: payload.term });\n  }\n  return result;\n}\n\n// --------------------------\n\nexport async function selectFromDb({\n  _postgres,\n  _term\n}: {\n    _postgres: Pool,\n    _term: string\n  }) {\n  const query = {\n    text:\n    `SELECT\n    original_terms.ontology_uid,\n    original_terms.confidence,\n    ontology_terms.ontology_uri,\n    ontology_terms.ontology_term,\n    ontology_terms.source_uri,\n    ontology_terms.short_name\n    FROM original_terms\n    INNER JOIN ontology_terms\n    ON ontology_terms.id = original_terms.ontology_uid\n    WHERE original = $1`,\n    values: [_term]\n  };\n\n  const result = await _postgres.query(query)\n    .then(data => data.rows);\n\n  return result;\n}\n\n// ------------------------\n\nexport async function getAnnotation({\n  payload,\n  _postgres,\n  _annotate = annotate\n  }: {\n    payload: { field: string, term: string },\n    _postgres: Pool\n    _annotate?: typeof annotate\n  }) {\n\n  // get ontology term from zooma\n  const standardised = await _annotate({ payload })\n    .then(data => data[0]);\n\n  if (standardised) {\n    const insertOntologyTerm = {\n      text: 'INSERT INTO ontology_terms(ontology_uri, ontology_term, source_uri, short_name) VALUES($1, $2, $3, $4) RETURNING * ',\n      values: [standardised.iri, standardised.term, standardised.source, standardised.short_name]\n    };\n\n    // insert standardised terms into table, return the row id to link to original term\n    const ontology_uid = await _postgres.query(insertOntologyTerm)\n      .then((data: any) => data.rows[0].id);\n\n    const createQuery = {\n      text: 'INSERT INTO original_terms(original, ontology_uid, confidence) VALUES($1, $2, $3)',\n      values: [payload.term, ontology_uid, standardised.confidence]\n    };\n\n    await _postgres.query(createQuery);\n  }\n}\n\n// --------------------------\n",
    "static": true,
    "longname": "/Users/alexanderbrinkmann/Documents/Repositories/metis/src/Annotation/controllerAnnotate.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 57,
    "kind": "variable",
    "name": "ajv",
    "memberof": "src/Annotation/controllerAnnotate.ts",
    "static": true,
    "longname": "src/Annotation/controllerAnnotate.ts~ajv",
    "access": "public",
    "export": false,
    "importPath": "metis/src/Annotation/controllerAnnotate.ts",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 58,
    "kind": "variable",
    "name": "schema",
    "memberof": "src/Annotation/controllerAnnotate.ts",
    "static": true,
    "longname": "src/Annotation/controllerAnnotate.ts~schema",
    "access": "public",
    "export": false,
    "importPath": "metis/src/Annotation/controllerAnnotate.ts",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 59,
    "kind": "function",
    "name": "get",
    "memberof": "src/Annotation/controllerAnnotate.ts",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "src/Annotation/controllerAnnotate.ts~get",
    "access": "public",
    "export": true,
    "importPath": "metis/src/Annotation/controllerAnnotate.ts",
    "importStyle": "{get}",
    "description": "",
    "lineNumber": 17,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "undefined",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 60,
    "kind": "function",
    "name": "selectFromDb",
    "memberof": "src/Annotation/controllerAnnotate.ts",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "src/Annotation/controllerAnnotate.ts~selectFromDb",
    "access": "public",
    "export": true,
    "importPath": "metis/src/Annotation/controllerAnnotate.ts",
    "importStyle": "{selectFromDb}",
    "description": "",
    "lineNumber": 52,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "undefined",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 61,
    "kind": "function",
    "name": "getAnnotation",
    "memberof": "src/Annotation/controllerAnnotate.ts",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "src/Annotation/controllerAnnotate.ts~getAnnotation",
    "access": "public",
    "export": true,
    "importPath": "metis/src/Annotation/controllerAnnotate.ts",
    "importStyle": "{getAnnotation}",
    "description": "",
    "lineNumber": 83,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "undefined",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 62,
    "kind": "file",
    "name": "src/Synonyms/controllerSynonyms.spec.ts",
    "content": "import * as test from 'tape';\nimport { Test } from 'tape';\nimport { stub } from 'sinon';\nimport { Pool } from 'pg';\n\nimport * as fs from 'fs';\nimport * as Ajv from 'ajv';\n\nimport { getSynonyms, populateSynonyms, getAllSynonyms, selectSynonymsFromDb, selectAllSynonymsFromDb, deleteSynonymsFromDb } from './controllerSynonyms';\n\n\ntest('Testing Synonyms controller', (t: Test) => {\n\n  t.test('Test get function when symbol and synonyms list are in database', async function (st: Test) {\n\n    const _postgres: any = { query: stub().returns(Promise.resolve()) };\n    const payload = { symbol: 'ERBB2' };\n    const _ajv: any = new Ajv();\n    const validateStub = stub(_ajv, 'validate').returns(true);\n    const _schema = stub();\n    const mockResult = [{\n      'list_synonyms':'[\\\"ERBB2\\\",\\\"NEU\\\",\\\"HER-2\\\",\\\"CD340\\\",\\\"HER2\\\"]'\n    }];\n    const _selectSynonymsFromDb = stub().returns(Promise.resolve(mockResult));\n\n    const mockResultSynonyms = ['ERBB2','NEU','HER-2','CD340','HER2'];\n    const _synonyms = stub().returns(Promise.resolve(mockResultSynonyms));\n\n    const result = await getSynonyms({ payload, _postgres, _selectSynonymsFromDb, _synonyms, _ajv, _schema })\n      .catch((err) => {\n        st.notOk(err, 'Function should not error');\n      });\n\n    st.assert((_ajv.validate as any).called, 'It calls validate once');\n    st.assert((_selectSynonymsFromDb as any).calledOnce, 'It calls _selectSynonymsFromDb');\n    st.false((_synonyms as any).calledOnce, 'It does not call _synonyms');\n    st.equals(_selectSynonymsFromDb.getCall(0).args[0]._symbol, 'ERBB2', '_selectSynonymsFromDb is called with the correct symbol');\n    st.deepEquals(result, mockResult, 'It returns the expected result');\n    st.end();\n\n  });\n\n  t.test('Test getSynonyms function when term is not in database and not available by HUGO', async function (st: Test) {\n\n    const _postgres: any = {};\n    const payload = { symbol: '1234' };\n    const _ajv: any = new Ajv();\n    const validateStub = stub(_ajv, 'validate').returns(true);\n    const _schema = stub();\n    const mockResult: any[] = [];\n    const _selectSynonymsFromDb = stub().returns(Promise.resolve(mockResult));\n\n    const mockResultSynonyms: any[] = [];\n    const _synonyms = stub().returns(Promise.resolve(mockResultSynonyms));\n\n    const result = await getSynonyms({ payload, _postgres, _selectSynonymsFromDb, _synonyms, _ajv, _schema })\n      .catch((err) => {\n        st.notOk(err, 'Function should not error');\n      });\n\n    st.assert(_selectSynonymsFromDb.calledTwice, 'It calls selectFromDb twice');\n    st.equals(_selectSynonymsFromDb.getCall(0).args[0]._symbol, '1234', 'selectFromDb is called with the correct term');\n    st.assert((_synonyms as any).calledOnce, 'It calls synonyms');\n    st.equals(_synonyms.getCall(0).args[0].payload.symbol, '1234', 'synonyms is called again with the correct term');\n    st.equals(_selectSynonymsFromDb.getCall(1).args[0]._symbol, '1234', 'selectFromDb is called again with the correct term');\n    st.same(result, mockResult, 'It returns the expected result');\n    st.end();\n  });\n\n  t.test('Test getAllSynonyms', async function (st: Test) {\n    const _postgres: any = {};\n    const mockResult = [{\n      'last_update':'123',\n      'list_synonyms':'[\\\"ERBB2\\\",\\\"NEU\\\",\\\"HER-2\\\",\\\"CD340\\\",\\\"HER2\\\"]'\n    },\n    {\n      'last_update':'456',\n      'list_synonyms':'[\\\"ERBB2\\\",\\\"NEU\\\",\\\"HER-2\\\"]'\n    }];\n\n    const expectedResult = [\n      [ '[\"ERBB2\",\"NEU\",\"HER-2\",\"CD340\",\"HER2\"]' ], [ '[\"ERBB2\",\"NEU\",\"HER-2\"]' ]\n    ];\n\n    const _selectAllSynonymsFromDb = stub().returns(Promise.resolve(mockResult));\n\n    const result = await getAllSynonyms({ _postgres, _selectAllSynonymsFromDb})\n      .catch((err) => {\n        st.notOk(err, 'Function should not error');\n      });\n\n    st.assert((_selectAllSynonymsFromDb).calledOnce, 'Trigger postgres call once');\n    st.deepEquals(result, expectedResult, 'It returns the expected result');\n    st.end();\n  });\n\n  t.test('Test selectAllSynonymsFromDb', async function (st: Test) {\n    const mockResult = {\n      rows: [{\n      'last_update':'123',\n      'list_synonyms':'[\\\"ERBB2\\\",\\\"NEU\\\",\\\"HER-2\\\",\\\"CD340\\\",\\\"HER2\\\"]'\n    },\n    {\n      'last_update':'456',\n      'list_synonyms':'[\\\"ERBB2\\\",\\\"NEU\\\",\\\"HER-2\\\"]'\n    }]};\n\n    const expectedResult = [{\n      'last_update':'123',\n      'list_synonyms':'[\\\"ERBB2\\\",\\\"NEU\\\",\\\"HER-2\\\",\\\"CD340\\\",\\\"HER2\\\"]'\n    },\n    {\n      'last_update':'456',\n      'list_synonyms':'[\\\"ERBB2\\\",\\\"NEU\\\",\\\"HER-2\\\"]'\n    }];\n\n    const _postgres: any = { query: stub().returns(Promise.resolve(mockResult)) };\n\n    const result = await selectAllSynonymsFromDb({ _postgres })\n      .catch((err) => {\n        st.notOk(err, 'Function should not error');\n      });\n\n    st.assert((_postgres.query as any).calledOnce, 'Query postgres once');\n    st.deepEquals(result, expectedResult, 'It returns the expected result');\n    st.end();\n  });\n\n  t.test('Test selectSynonymsFromDb', async function (st: Test) {\n    const _symbol = 'ERBB2';\n    const mockResult = {\n      rows: [{\n      'last_update':'123',\n      'list_synonyms':'[\\\"ERBB2\\\",\\\"NEU\\\",\\\"HER-2\\\",\\\"CD340\\\",\\\"HER2\\\"]'\n    },\n    {\n      'last_update':'456',\n      'list_synonyms':'[\\\"ERBB2\\\",\\\"NEU\\\",\\\"HER-2\\\"]'\n    }]};\n\n    const expectedResult = [{\n      'last_update':'123',\n      'list_synonyms':'[\\\"ERBB2\\\",\\\"NEU\\\",\\\"HER-2\\\",\\\"CD340\\\",\\\"HER2\\\"]'\n    },\n    {\n      'last_update':'456',\n      'list_synonyms':'[\\\"ERBB2\\\",\\\"NEU\\\",\\\"HER-2\\\"]'\n    }];\n\n    const _postgres: any = { query: stub().returns(Promise.resolve(mockResult)) };\n\n    const result = await selectSynonymsFromDb({ _postgres , _symbol })\n      .catch((err) => {\n        st.notOk(err, 'Function should not error');\n      });\n\n    st.assert((_postgres.query as any).calledOnce, 'Query postgres once');\n    st.deepEquals(result, expectedResult, 'It returns the expected result');\n    st.end();\n  });\n\n  t.test('Test populateSynonyms', async function (st: Test) {\n\n    const _postgres: any = { query: stub().returns(Promise.resolve()) };\n\n    const mockResult = [ [ 'A1BG-AS1', 'FLJ23569' ],\n        [ 'A1CF', 'ACF', 'ASP', 'ACF64', 'ACF65', 'APOBEC1CF' ],\n        [ 'A2M', 'FWP007', 'S863-7', 'CPAMD5' ],\n        [ 'ABAT', 'GABAT' ],\n        [ 'ABCA1', 'TGD' ] ];\n\n    const _allSynonyms: any = stub().returns(Promise.resolve(mockResult));\n\n    await populateSynonyms({ _postgres, _allSynonyms })\n    .catch(function(e) {\n      st.ok(e, 'TypeError: Cannot read property \\'0\\' of undefined');\n    });\n\n    st.ok((_postgres.query as any).called, 'true');\n\n    st.end();\n  });\n\n  t.test('Test deleteSynonymsFromDb', async function (st: Test) {\n    const _postgres: any = { query: stub().returns(Promise.resolve()) };\n\n    const listSynonyms = '(\"ERBB2\",\"NEU\",\"HER-2\",\"CD340\",\"HER2\")';\n\n    const result = await deleteSynonymsFromDb({ _postgres, listSynonyms})\n      .catch((err) => {\n        st.notOk(err, 'Function should not error');\n      });\n\n    st.assert((_postgres.query as any).calledTwice, 'Trigger postgres call twice');\n    st.end();\n  });\n\n  t.end();\n});\n",
    "static": true,
    "longname": "/Users/alexanderbrinkmann/Documents/Repositories/metis/src/Synonyms/controllerSynonyms.spec.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 63,
    "kind": "file",
    "name": "src/Synonyms/controllerSynonyms.ts",
    "content": "import { Pool } from 'pg';\nimport { synonyms, allSynonyms } from './synonyms';\nimport * as fs from 'fs';\nimport * as Ajv from 'ajv';\nimport * as R from 'ramda';\n\nconst ajv = new Ajv({ allErrors: true, verbose: true });\n\n// --------------------------\n\nconst schema: any = JSON.parse(fs.readFileSync('./schemas/synonyms-is-valid.json', 'utf8'));\n\n/**\n * @desc This method is linked to the action iris.synonyms.get. It checks in the database whether a list of synonyms for the given symbol exists.\n * If it does not exist or the last update is older than 30 days, a request is send to the HUGO API at gennames.org to retrieve the required synonyms.\n * The response from the HUGO is stored to the database and returned.\n *\n * @param {String} payload - contains the requested symbol as a string.\n * @param {Object} _postgres - Pass postgres element to work with database.\n * @returns {String} A list of synonyms for the requested symbol.\n */\n\nexport async function getSynonyms({\n  payload,\n  _postgres,\n  _selectSynonymsFromDb = selectSynonymsFromDb,\n  _deleteSynonymsFromDb = deleteSynonymsFromDb,\n  _updateSynonyms = updateSynonyms,\n  _synonyms = synonyms,\n  _ajv = ajv,\n  _schema = schema\n }: {\n    payload: { symbol: string },\n    _postgres: Pool,\n    _selectSynonymsFromDb?: typeof selectSynonymsFromDb,\n    _deleteSynonymsFromDb?: typeof deleteSynonymsFromDb,\n    _updateSynonyms?: typeof updateSynonyms,\n    _synonyms?: typeof synonyms,\n    _ajv?: typeof ajv,\n    _schema?: typeof schema\n  }): Promise<any[]> {\n\n  const valid = _ajv.validate(_schema, payload);\n  if (!valid) {\n    console.log(_ajv.errors);\n    throw new Error('Payload schema error');\n  }\n\n  let result = await _selectSynonymsFromDb({ _postgres, _symbol: payload.symbol });\n\n  // if result undefined (ie. no rows found)\n  const { symbol } = payload;\n  if (R.isEmpty(result) && payload.symbol) {\n\n    await _updateSynonyms({ payload: { symbol }, _postgres, _synonyms });\n    result = await _selectSynonymsFromDb({ _postgres, _symbol: payload.symbol });\n  } else if (R.isEmpty(result) && payload.symbol && ((Date.now() - result[0].last_update) / (1000 * 60 * 60 * 24)) > 30) { // Update synonyms when last updated 31 days ago.\n    // Delete entry first and trigger update afterwards\n\n    R.map(R.compose(c =>_deleteSynonymsFromDb({_postgres, listSynonyms : c }), R.prop('list_synonyms')), result);\n\n    await _updateSynonyms({ payload: { symbol }, _postgres, _synonyms });\n    result = await _selectSynonymsFromDb({ _postgres, _symbol: payload.symbol });\n  }\n  const reduceToListSynonyms = R.pick(['list_synonyms']);\n  return R.map(reduceToListSynonyms, result);\n}\n\n\n/**\n * @desc This method is linked to the action iris.synonyms.all and returns all stored lists of synonyms from the database.\n *\n * @param {Object} _postgres - Pass postgres element to work with database.\n * @returns {Promise} A list of all synonym lists in the database.\n */\nexport async function getAllSynonyms({\n  _postgres,\n  _selectAllSynonymsFromDb = selectAllSynonymsFromDb\n }: {\n    _postgres: Pool,\n    _selectAllSynonymsFromDb?: typeof selectAllSynonymsFromDb\n  }): Promise<any[]> {\n\n  const result = await _selectAllSynonymsFromDb({ _postgres });\n  const reduceToListSynonyms = R.pick(['list_synonyms']);\n\n  return R.pipe(R.map(reduceToListSynonyms), R.map(R.values))(result);\n}\n\n/**\n * @desc This method returns the list of synonyms for the provided symbol.\n *\n * @param {Object} _postgres - Pass postgres element to access the database.\n * @param {String} _symbol - Symbol for which the synonyms are requested.\n * @returns {Promise} A list of synonyms from the database.\n */\nexport async function selectSynonymsFromDb({\n  _postgres,\n  _symbol\n}: {\n    _postgres: Pool,\n    _symbol: string\n  }) {\n  const query = {\n    text:\n      `SELECT list_synonyms, last_update\n    FROM synonyms\n    INNER JOIN symbols\n    ON synonyms.id = symbols.synonyms_uid\n    WHERE symbols.symbol = $1`,\n    values: [_symbol]\n  };\n\n  const result = _postgres.query(query)\n    .then(data => data.rows)\n    .catch((err: any) => {\n      //console.log('_request error: ' + err);\n      throw new Error('_request error: ' + err);\n    });\n\n  return result;\n}\n\n/**\n * @desc This method returns all lists of synonyms stored in the database.\n * @param {Object} _postgres - Pass postgres element to access the database.\n * @returns {Promise} A list of synonyms from the database.\n */\nexport async function selectAllSynonymsFromDb({\n  _postgres\n}: {\n    _postgres: Pool\n  }) {\n  const query = {\n    text:\n      `SELECT list_synonyms FROM synonyms`\n  };\n\n  const result = _postgres.query(query)\n    .then(data => data.rows)\n    .catch((err: any) => {\n      //console.log('_request error: ' + err);\n      throw new Error('_request error: ' + err);\n    });\n\n  return result;\n}\n\n/**\n * @desc This method returns all lists of synonyms stored in the database.\n * @param {Object} _postgres - Pass postgres element to access the database.\n * @returns {Promise} A list of synonyms from the database.\n */\n\nasync function updateSynonyms({\n  payload,\n  _postgres,\n  _synonyms = synonyms,\n  _storeSynonyms = storeSynonyms\n  }: {\n    payload: { symbol: string },\n    _postgres: Pool,\n    _synonyms?: typeof synonyms,\n    _storeSynonyms?: typeof storeSynonyms\n  }) {\n\n  // get synonyms from HUGO\n  const listlistSynonyms = await _synonyms({ payload });\n  listlistSynonyms.forEach((listSynonyms: any) => {\n    _storeSynonyms({ listSynonyms, _postgres });\n  });\n}\n\n/**\n * @desc This method resets the current content in the database and replaces it with the response from Hugo for all synonyms.\n * @param {Object} _postgres - Pass postgres element to access the database.\n */\nexport async function populateSynonyms({\n  _postgres,\n  _deleteAllSynonymsFromDb = deleteAllSynonymsFromDb,\n  _storeSynonyms = storeSynonyms,\n  _allSynonyms = allSynonyms\n  }: {\n    _postgres: Pool,\n    _deleteAllSynonymsFromDb?: typeof deleteAllSynonymsFromDb,\n    _storeSynonyms?: typeof storeSynonyms,\n    _allSynonyms?: typeof allSynonyms\n  }) {\n\n  // get synonyms from HUGO\n  _deleteAllSynonymsFromDb({ _postgres });\n  const listlistSynonyms = await _allSynonyms({});\n  listlistSynonyms.forEach((listSynonyms: any) => {\n    _storeSynonyms({ listSynonyms, _postgres });\n  });\n  console.log('Database populated!');\n\n}\n\n/**\n * @desc This method stores synonyms and symbols in the database.\n * @param {Object} _postgres - Pass postgres element to access the database.\n */\nasync function storeSynonyms({\n  listSynonyms,\n  _postgres\n  }: {\n    listSynonyms: any,\n    _postgres: Pool\n  }) {\n\n  if (listSynonyms && listSynonyms.length >= 1) {\n    const convertedListSynonyms = JSON.stringify(listSynonyms).replace('[', '\\[').replace(']', '\\]').replace('\\'', '');\n    const insertSynonyms = {\n      text: 'INSERT INTO synonyms(list_synonyms, last_update) VALUES($1, CURRENT_TIMESTAMP) RETURNING * ',\n      values: [convertedListSynonyms]\n    };\n\n    const synonyms_uid = await _postgres.query(insertSynonyms)\n      .then((data: any) => data.rows[0].id)\n      .catch((err: any) => {\n        //console.log('_request error: ' + err);\n        throw new Error('_request error: ' + err);\n      });\n\n    listSynonyms.forEach(function(synonymToken : string) {\n      const createQuery = {\n        text: 'INSERT INTO symbols(synonyms_uid, symbol) VALUES($1, $2)',\n        values: [synonyms_uid, synonymToken]\n      };\n\n      _postgres.query(createQuery).catch((err: any) => {\n        //console.log('_request error: ' + err);\n        throw new Error('_request error: ' + err);\n      });\n    });\n  }\n}\n\n/**\n * @desc This method deletes synonyms and symbols from the database.\n * @param {Object} _postgres - Pass postgres element to access the database.\n * @param {Promise} listSynonyms - The list of synonyms, which has to be deleted from the database.\n */\nexport async function deleteSynonymsFromDb({\n  _postgres,\n  listSynonyms\n}: {\n    _postgres: Pool,\n    listSynonyms: any\n  }) {\n\n  const stringListSynonyms = listSynonyms.replace('[', '(').replace(']', ')').replace(/\\\"/g, '\\'');\n  const queryDeleteSymbols = {\n    text: `DELETE FROM symbols WHERE \"symbol\" IN `.concat(stringListSynonyms)\n  };\n\n  _postgres.query(queryDeleteSymbols)\n  .catch((err: any) => {\n    //console.log('_request error: ' + err);\n    throw new Error('_request error: ' + err);\n  });\n\n  const queryDeleteSynonyms = {\n    text:\n      `DELETE FROM synonyms WHERE list_synonyms = $1`,\n    values: [listSynonyms]\n  };\n\n  _postgres.query(queryDeleteSynonyms)\n  .catch((err: any) => {\n    //console.log('_request error: ' + err);\n    throw new Error('_request error: ' + err);\n  });\n}\n/**\n * @desc This method deletes all synonyms and symbols from the database.\n * @param {Object} _postgres - Pass postgres element to access the database.\n */\nfunction deleteAllSynonymsFromDb({\n  _postgres\n}: {\n    _postgres: Pool\n  }) {\n  const queryDeleteSymbols = {\n    text: `DELETE FROM symbols`\n  };\n\n  _postgres.query(queryDeleteSymbols)\n  .catch((err: any) => {\n    //console.log('_request error: ' + err);\n    throw new Error('_request error: ' + err);\n  });\n\n  const queryDeleteSynonyms = {\n    text:\n      `DELETE FROM synonyms`\n  };\n\n  _postgres.query(queryDeleteSynonyms)\n  .catch((err: any) => {\n    //console.log('_request error: ' + err);\n    throw new Error('_request error: ' + err);\n  });\n}\n",
    "static": true,
    "longname": "/Users/alexanderbrinkmann/Documents/Repositories/metis/src/Synonyms/controllerSynonyms.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 64,
    "kind": "variable",
    "name": "ajv",
    "memberof": "src/Synonyms/controllerSynonyms.ts",
    "static": true,
    "longname": "src/Synonyms/controllerSynonyms.ts~ajv",
    "access": "public",
    "export": false,
    "importPath": "metis/src/Synonyms/controllerSynonyms.ts",
    "importStyle": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 65,
    "kind": "variable",
    "name": "schema",
    "memberof": "src/Synonyms/controllerSynonyms.ts",
    "static": true,
    "longname": "src/Synonyms/controllerSynonyms.ts~schema",
    "access": "public",
    "export": false,
    "importPath": "metis/src/Synonyms/controllerSynonyms.ts",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 66,
    "kind": "function",
    "name": "getSynonyms",
    "memberof": "src/Synonyms/controllerSynonyms.ts",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "src/Synonyms/controllerSynonyms.ts~getSynonyms",
    "access": "public",
    "export": true,
    "importPath": "metis/src/Synonyms/controllerSynonyms.ts",
    "importStyle": "{getSynonyms}",
    "description": "This method is linked to the action iris.synonyms.get. It checks in the database whether a list of synonyms for the given symbol exists.\nIf it does not exist or the last update is older than 30 days, a request is send to the HUGO API at gennames.org to retrieve the required synonyms.\nThe response from the HUGO is stored to the database and returned.",
    "lineNumber": 27,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{String} A list of synonyms for the requested symbol."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "payload",
        "description": "contains the requested symbol as a string."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "_postgres",
        "description": "Pass postgres element to work with database."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "String"
      ],
      "spread": false,
      "description": "A list of synonyms for the requested symbol."
    }
  },
  {
    "__docId__": 67,
    "kind": "function",
    "name": "getAllSynonyms",
    "memberof": "src/Synonyms/controllerSynonyms.ts",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "src/Synonyms/controllerSynonyms.ts~getAllSynonyms",
    "access": "public",
    "export": true,
    "importPath": "metis/src/Synonyms/controllerSynonyms.ts",
    "importStyle": "{getAllSynonyms}",
    "description": "This method is linked to the action iris.synonyms.all and returns all stored lists of synonyms from the database.",
    "lineNumber": 65,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} A list of all synonym lists in the database."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "_postgres",
        "description": "Pass postgres element to work with database."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "A list of all synonym lists in the database."
    }
  },
  {
    "__docId__": 68,
    "kind": "function",
    "name": "selectSynonymsFromDb",
    "memberof": "src/Synonyms/controllerSynonyms.ts",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "src/Synonyms/controllerSynonyms.ts~selectSynonymsFromDb",
    "access": "public",
    "export": true,
    "importPath": "metis/src/Synonyms/controllerSynonyms.ts",
    "importStyle": "{selectSynonymsFromDb}",
    "description": "This method returns the list of synonyms for the provided symbol.",
    "lineNumber": 85,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} A list of synonyms from the database."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "_postgres",
        "description": "Pass postgres element to access the database."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "_symbol",
        "description": "Symbol for which the synonyms are requested."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "A list of synonyms from the database."
    }
  },
  {
    "__docId__": 69,
    "kind": "function",
    "name": "selectAllSynonymsFromDb",
    "memberof": "src/Synonyms/controllerSynonyms.ts",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "src/Synonyms/controllerSynonyms.ts~selectAllSynonymsFromDb",
    "access": "public",
    "export": true,
    "importPath": "metis/src/Synonyms/controllerSynonyms.ts",
    "importStyle": "{selectAllSynonymsFromDb}",
    "description": "This method returns all lists of synonyms stored in the database.",
    "lineNumber": 115,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} A list of synonyms from the database."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "_postgres",
        "description": "Pass postgres element to access the database."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "A list of synonyms from the database."
    }
  },
  {
    "__docId__": 70,
    "kind": "function",
    "name": "updateSynonyms",
    "memberof": "src/Synonyms/controllerSynonyms.ts",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "src/Synonyms/controllerSynonyms.ts~updateSynonyms",
    "access": "public",
    "export": false,
    "importPath": "metis/src/Synonyms/controllerSynonyms.ts",
    "importStyle": null,
    "description": "This method returns all lists of synonyms stored in the database.",
    "lineNumber": 140,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} A list of synonyms from the database."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "_postgres",
        "description": "Pass postgres element to access the database."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "A list of synonyms from the database."
    },
    "ignore": true
  },
  {
    "__docId__": 71,
    "kind": "function",
    "name": "populateSynonyms",
    "memberof": "src/Synonyms/controllerSynonyms.ts",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "src/Synonyms/controllerSynonyms.ts~populateSynonyms",
    "access": "public",
    "export": true,
    "importPath": "metis/src/Synonyms/controllerSynonyms.ts",
    "importStyle": "{populateSynonyms}",
    "description": "This method resets the current content in the database and replaces it with the response from Hugo for all synonyms.",
    "lineNumber": 159,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "_postgres",
        "description": "Pass postgres element to access the database."
      }
    ],
    "return": null
  },
  {
    "__docId__": 72,
    "kind": "function",
    "name": "storeSynonyms",
    "memberof": "src/Synonyms/controllerSynonyms.ts",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "src/Synonyms/controllerSynonyms.ts~storeSynonyms",
    "access": "public",
    "export": false,
    "importPath": "metis/src/Synonyms/controllerSynonyms.ts",
    "importStyle": null,
    "description": "This method stores synonyms and symbols in the database.",
    "lineNumber": 180,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "_postgres",
        "description": "Pass postgres element to access the database."
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 73,
    "kind": "function",
    "name": "deleteSynonymsFromDb",
    "memberof": "src/Synonyms/controllerSynonyms.ts",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "src/Synonyms/controllerSynonyms.ts~deleteSynonymsFromDb",
    "access": "public",
    "export": true,
    "importPath": "metis/src/Synonyms/controllerSynonyms.ts",
    "importStyle": "{deleteSynonymsFromDb}",
    "description": "This method deletes synonyms and symbols from the database.",
    "lineNumber": 218,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "_postgres",
        "description": "Pass postgres element to access the database."
      },
      {
        "nullable": null,
        "types": [
          "Promise"
        ],
        "spread": false,
        "optional": false,
        "name": "listSynonyms",
        "description": "The list of synonyms, which has to be deleted from the database."
      }
    ],
    "return": null
  },
  {
    "__docId__": 74,
    "kind": "function",
    "name": "deleteAllSynonymsFromDb",
    "memberof": "src/Synonyms/controllerSynonyms.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Synonyms/controllerSynonyms.ts~deleteAllSynonymsFromDb",
    "access": "public",
    "export": false,
    "importPath": "metis/src/Synonyms/controllerSynonyms.ts",
    "importStyle": null,
    "description": "This method deletes all synonyms and symbols from the database.",
    "lineNumber": 250,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "_postgres",
        "description": "Pass postgres element to access the database."
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 75,
    "kind": "file",
    "name": "src/Synonyms/synonyms-schema.spec.ts",
    "content": "import * as test from 'tape';\nimport { Test } from 'tape';\nimport * as Ajv from 'ajv';\nimport * as fs from 'fs';\n\n//--------------------------\n\nconst schemas: any[] = [\n  JSON.parse(fs.readFileSync('./schemas/synonyms-is-valid.json', 'utf8'))\n];\n\nconst ajv = new Ajv({ allErrors: true, verbose: true, schemas });\n\ntest('The synonyms schema is valid', (t: Test) => {\n  const schema = ajv.getSchema('synonyms-is-valid.json');\n  t.ok(schema !== undefined, 'Synonyms schema loads');\n  t.end();\n});\n\ntest('Symbol is required', (t: Test) => {\n  const schema = ajv.getSchema('synonyms-is-valid.json');\n  const json = { };\n  const valid = schema(json);\n  t.notOk(valid, 'Object without symbol is not valid payload');\n  t.ok(schema.errors, 'There are errors');\n  if (schema.errors) {\n    t.equals(schema.errors[0]['message'], 'should have required property \\'symbol\\'', 'Correct error message');\n  }\n  t.end();\n});\n",
    "static": true,
    "longname": "/Users/alexanderbrinkmann/Documents/Repositories/metis/src/Synonyms/synonyms-schema.spec.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 76,
    "kind": "variable",
    "name": "schemas",
    "memberof": "src/Synonyms/synonyms-schema.spec.ts",
    "static": true,
    "longname": "src/Synonyms/synonyms-schema.spec.ts~schemas",
    "access": "public",
    "export": false,
    "importPath": "metis/src/Synonyms/synonyms-schema.spec.ts",
    "importStyle": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "type": {
      "types": [
        "undefined[]"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 77,
    "kind": "variable",
    "name": "ajv",
    "memberof": "src/Synonyms/synonyms-schema.spec.ts",
    "static": true,
    "longname": "src/Synonyms/synonyms-schema.spec.ts~ajv",
    "access": "public",
    "export": false,
    "importPath": "metis/src/Synonyms/synonyms-schema.spec.ts",
    "importStyle": null,
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 78,
    "kind": "file",
    "name": "src/Synonyms/synonyms.spec.ts",
    "content": "import * as test from 'tape';\nimport { Test } from 'tape';\nimport { stub } from 'sinon';\nimport * as fs from 'fs';\nimport { synonyms, allSynonyms } from './synonyms';\n\n//-------------------------------\n\ntest('Testing getSynonym service', (t: Test) => {\n  t.test('Returns synonyms', async function (st: Test) {\n\n    const symbol: string = 'ERBB2';\n    const synonymsResult = [ ['ERBB2', 'NEU', 'HER-2', 'CD340', 'HER2'] ];\n\n    const requestResponse: any = {\n      'response': {\n        'docs': [{\n          'symbol': 'ERBB2',\n          'name': 'erb-b2 receptor tyrosine kinase 2',\n          'alias_symbol': [\n            'NEU',\n            'HER-2',\n            'CD340',\n            'HER2'\n          ],\n          'alias_name': [\n            'neuro/glioblastoma derived oncogene homolog',\n            'human epidermal growth factor receptor 2'\n          ]\n        }]\n      }\n    };\n\n    const _request: any = stub().returns(Promise.resolve(requestResponse));\n\n    st.equals(typeof synonyms, 'function', 'The module exports a function called synonyms');\n\n    const result = await synonyms({ payload: { symbol }, _request })\n      .then(function (data: any) {\n        //console.log('got data', data);\n        return data;\n      }).catch((err: any) => {\n        console.log('API call failed...' + err);\n        st.notOk(err, 'There is an error');\n      });\n    st.assert(result instanceof Object, 'Returns an object');\n    st.deepEquals(result, synonymsResult, 'The final result is equal to the expected result');\n    st.end();\n  });\n\n  //----------------------------\n\n  t.test('Returns synonyms via alias', async function (st: Test) {\n\n    const symbol: string = 'HER2';\n    const synonymsResult = [ ['ERBB2', 'NEU', 'HER-2', 'CD340', 'HER2'] ];\n\n    const requestResponse: any = {\n      'response': {\n        'docs': [{\n          'symbol': 'ERBB2',\n          'name': 'erb-b2 receptor tyrosine kinase 2',\n          'alias_symbol': [\n            'NEU',\n            'HER-2',\n            'CD340',\n            'HER2'\n          ],\n          'alias_name': [\n            'neuro/glioblastoma derived oncogene homolog',\n            'human epidermal growth factor receptor 2'\n          ]\n        }]\n      }\n    };\n\n    const _request: any = stub().returns(Promise.resolve(requestResponse));\n\n    st.equals(typeof synonyms, 'function', 'The module exports a function called synonyms');\n\n    const result = await synonyms({ payload: { symbol }, _request })\n      .then(function (data: any) {\n        //console.log('got data', data);\n        return data;\n      }).catch((err: any) => {\n        console.log('API call failed...' + err);\n        st.notOk(err, 'There is an error');\n      });\n    st.assert(result instanceof Object, 'Returns an object');\n    st.deepEquals(result, synonymsResult, 'The final result is equal to the expected result');\n    st.end();\n  });\n\n  t.test('Fail to find a synonym', async function (st: Test) {\n\n    const symbol: string = 'zzzzyzzz';\n    const synonymsResult: any[] = [];\n\n    const requestResponse: any = {\n      'response': {\n        'responseHeader': {\n          'status': 0,\n          'QTime': 1\n        }\n      }\n    };\n\n    const _request: any = stub().returns(Promise.resolve(requestResponse));\n\n    st.equals(typeof synonyms, 'function', 'The module exports a function called synonyms');\n\n    const result = await synonyms({ payload: { symbol }, _request })\n      .then(function (data: any) {\n        //console.log('got data', data);\n        return data;\n      }).catch((err: any) => {\n        console.log('API call failed...' + err);\n        st.notOk(err, 'There is an error');\n      });\n    st.assert(result instanceof Object, 'Returns an object');\n    st.deepEquals(result, synonymsResult, 'The final result is equal to the expected result');\n    st.end();\n  });\n\n  t.test('Returns allSynonyms', async function (st: Test) {\n    const synonymsResult = [['ERBB2', 'NEU', 'HER-2', 'CD340', 'HER2'],\n                            ['A1CF','ACF','ASP','ACF64','ACF65','APOBEC1CF']];\n\n    const requestResponse: any = {\n      'response': {\n        'docs': [{\n          'symbol': 'ERBB2',\n          'name': 'alpha-1-B glycoprotein',\n          'alias_symbol': [\n            'NEU',\n            'HER-2',\n            'CD340',\n            'HER2'\n          ],\n          'alias_name': [\n            'neuro/glioblastoma derived oncogene homolog',\n            'human epidermal growth factor receptor 2'\n          ]\n        },\n        {\n          'symbol': 'A1CF',\n          'name': 'erb-b2 receptor tyrosine kinase 2',\n          'alias_symbol': [\n            'ACF',\n            'ASP',\n            'ACF64',\n            'ACF65',\n            'APOBEC1CF'\n          ],\n          'location': '10q11.23'\n        }]\n      }\n    };\n\n    const _request: any = stub().returns(Promise.resolve(requestResponse));\n\n    st.equals(typeof allSynonyms, 'function', 'The module exports a function called allSynonyms');\n\n    const result = await allSynonyms({ _request })\n      .then(function (data: any) {\n        //console.log('got data', data);\n        return data;\n      }).catch((err: any) => {\n        console.log('API call failed...' + err);\n        st.notOk(err, 'There is an error');\n      });\n    st.assert(result instanceof Object, 'Returns an object');\n    st.deepEquals(result, synonymsResult, 'The final result is equal to the expected result');\n    st.end();\n  });\n\n  t.end();\n});\n",
    "static": true,
    "longname": "/Users/alexanderbrinkmann/Documents/Repositories/metis/src/Synonyms/synonyms.spec.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 79,
    "kind": "file",
    "name": "src/Synonyms/synonyms.ts",
    "content": "import * as request from 'request-promise';\nimport * as fs from 'fs';\nimport * as Ajv from 'ajv';\n\nimport * as R from 'ramda';\n\n/**\n * @desc This method sends a request to the HUGO API at gennames.org to retrieve the required synonyms.\n * Example: https://rest.genenames.org/fetch/symbol/ERBB2\n * If it does not retrieve the synonyms via the standard symbol, the alias symbol is used to retrieve results.\n *\n * @param {String} payload - contains the requested symbol as a string.\n * @returns {Promise} A list of synonyms for the requested symbol.\n */\nexport async function synonyms({\n   payload,\n  _request = request\n  }: {\n    payload: { symbol: string },\n    _request?: typeof request\n  }) {\n\n  const data: any = payload;\n  const symbol: string = payload.symbol;\n  const url_symbol = `https://rest.genenames.org/fetch/symbol/${symbol}`;\n\n  const options_symbol = {\n    method: 'GET',\n    uri: url_symbol as string,\n    json: true\n  };\n\n  const result: any = await _request(options_symbol)\n    .then((response: any) => {\n      if (!R.isNil(response.docs)) {\n        return consolidateResult(response);\n      } else {\n        return aliasSynonyms({ symbol_alias: symbol, _request });\n      }\n    })\n    .catch((err: any) => {\n      //console.log('_request error: ' + err);\n      throw new Error('_request error: ' + err);\n    });\n\n  return result;\n}\n\n/**\n * @desc This method sends a request to the HUGO API at gennames.org to retrieve all symbols and corresponding synonyms.\n * @returns {Promise} All lists of synonyms provided by HUGO.\n */\nexport async function allSynonyms({\n _request = request\n }: {\n    _request?: typeof request\n  }) {\n  const url_all = 'http://rest.genenames.org/fetch/status/Approved';\n\n  const options_all = {\n    method: 'GET',\n    uri: url_all as string,\n    json: true\n  };\n\n  const json_all: any = _request(options_all)\n    .then((response: any) => {\n      return consolidateResult(response);\n    })\n    .catch((err: any) => {\n      //console.log('_request error: ' + err);\n      throw new Error('_request error: ' + err);\n    });\n  return json_all;\n}\n\n/**\n * @desc This method sends a request to the HUGO API at gennames.org to retrieve the required synonyms via the aliases.\n * Example: https://rest.genenames.org/fetch/alias_symbol/HER-2\n *\n * @param {JSON} payload - contains the requested symbol as a string.\n * @returns {String[]} A list of synonyms for the requested symbol.\n */\n\nfunction aliasSynonyms({\n  symbol_alias,\n  _request = request\n}: {\n    symbol_alias: string,\n    _request?: typeof request\n  }) {\n  const url_aliassymbol = `https://rest.genenames.org/fetch/alias_symbol/${symbol_alias}`;\n\n  const options_aliassymbol = {\n    method: 'GET',\n    uri: url_aliassymbol as string,\n    json: true\n  };\n\n  const json_aliassymbol: any = _request(options_aliassymbol)\n    .then((response: any) => {\n      return consolidateResult(response);\n    })\n    .catch((err: any) => {\n      //console.log('_request error: ' + err);\n      throw new Error('_request error: ' + err);\n    });\n\n  return json_aliassymbol;\n}\n\n/**\n * @desc This helper method reduces the HUGO response to the needed format and is therefore called by all request functions.\n *\n * @param {JSON} - Response from HUGO\n * @returns {String[]} A consolidated json of synonyms\n */\nfunction consolidateResult({\n  response\n}:{\n    response: any\n  }) {\n    if ( !R.isNil(response.docs) ) {\n      const filterUndefined = R.pipe(R.prop('alias_symbol'), R.isNil, R.not);\n      const definedAlias = R.filter(filterUndefined, response.docs);\n      return R.pipe(R.map(R.pick(['symbol', 'alias_symbol'])), R.map(R.values), R.map(R.flatten))(definedAlias);\n\n     /*\n      * TO-DO:  A potential problem maybe that one alias_symbol can belong to multiple symbols.\n      *         So it maybe useful to remove those alias_symbols, which belong to multiple symbols.\n      *         Example: A --> B,C,D\n      *                  E --> B,F,G\n      *                  Remove B, because it is a synonyms for A and E(?)\n      */\n\n    } else {\n      return [];\n    }\n  }\n",
    "static": true,
    "longname": "/Users/alexanderbrinkmann/Documents/Repositories/metis/src/Synonyms/synonyms.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 80,
    "kind": "function",
    "name": "synonyms",
    "memberof": "src/Synonyms/synonyms.ts",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "src/Synonyms/synonyms.ts~synonyms",
    "access": "public",
    "export": true,
    "importPath": "metis/src/Synonyms/synonyms.ts",
    "importStyle": "{synonyms}",
    "description": "This method sends a request to the HUGO API at gennames.org to retrieve the required synonyms.\nExample: https://rest.genenames.org/fetch/symbol/ERBB2\nIf it does not retrieve the synonyms via the standard symbol, the alias symbol is used to retrieve results.",
    "lineNumber": 19,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} A list of synonyms for the requested symbol."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "payload",
        "description": "contains the requested symbol as a string."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "A list of synonyms for the requested symbol."
    }
  },
  {
    "__docId__": 81,
    "kind": "function",
    "name": "allSynonyms",
    "memberof": "src/Synonyms/synonyms.ts",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "src/Synonyms/synonyms.ts~allSynonyms",
    "access": "public",
    "export": true,
    "importPath": "metis/src/Synonyms/synonyms.ts",
    "importStyle": "{allSynonyms}",
    "description": "This method sends a request to the HUGO API at gennames.org to retrieve all symbols and corresponding synonyms.",
    "lineNumber": 55,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} All lists of synonyms provided by HUGO."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "All lists of synonyms provided by HUGO."
    },
    "params": [
      {
        "name": "objectPattern",
        "types": [
          "{\"_request\": *}"
        ],
        "defaultRaw": {
          "_request": null
        },
        "defaultValue": "{\"_request\":null}"
      }
    ]
  },
  {
    "__docId__": 82,
    "kind": "function",
    "name": "aliasSynonyms",
    "memberof": "src/Synonyms/synonyms.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Synonyms/synonyms.ts~aliasSynonyms",
    "access": "public",
    "export": false,
    "importPath": "metis/src/Synonyms/synonyms.ts",
    "importStyle": null,
    "description": "This method sends a request to the HUGO API at gennames.org to retrieve the required synonyms via the aliases.\nExample: https://rest.genenames.org/fetch/alias_symbol/HER-2",
    "lineNumber": 87,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{String[]} A list of synonyms for the requested symbol."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "JSON"
        ],
        "spread": false,
        "optional": false,
        "name": "payload",
        "description": "contains the requested symbol as a string."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "String[]"
      ],
      "spread": false,
      "description": "A list of synonyms for the requested symbol."
    },
    "ignore": true
  },
  {
    "__docId__": 83,
    "kind": "function",
    "name": "consolidateResult",
    "memberof": "src/Synonyms/synonyms.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/Synonyms/synonyms.ts~consolidateResult",
    "access": "public",
    "export": false,
    "importPath": "metis/src/Synonyms/synonyms.ts",
    "importStyle": null,
    "description": "- Response from HUGO",
    "lineNumber": 118,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "undefined",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*[]"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 84,
    "kind": "file",
    "name": "src/index.ts",
    "content": "import init from './service';\n\ninit({})\n  .then(() => {\n    console.log(`Service is running`);\n  })\n  .catch(console.error);\n",
    "static": true,
    "longname": "/Users/alexanderbrinkmann/Documents/Repositories/metis/src/index.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 85,
    "kind": "file",
    "name": "src/service.spec.ts",
    "content": "import * as test from 'tape';\nimport { Test } from 'tape';\nimport { stub } from 'sinon';\nimport init from './service';\n\ntest('Testing basic service', (t: Test) => {\n  async function _test() {\n\n    const _pack = { version: '1', name: 'metis' };\n    const _iris = { request: stub() as any, register: stub().returns(Promise.resolve()) as any };\n    const _irisSetup = stub().returns(Promise.resolve(_iris));\n    const irisConfig = { url: 'a', exchange: 'b', namespace: 'c' };\n    const _config = { get: stub().returns(irisConfig) } as any;\n\n    t.equals(typeof init, 'function', 'Service exports a function');\n\n    const setupResult = init({ _pack, _irisSetup, _config });\n\n    t.ok(setupResult instanceof Promise, 'Service setup must return a promise');\n\n    await setupResult\n      .then(() => {\n        t.ok(true, 'Yeah, service setup does not blow up');\n      })\n      .catch(() => {\n        t.notOk(true, 'Setup should not blow up at this point');\n      });\n\n    t.ok(_iris.register.called, 'Add from iris is called');\n\n    let addCall = _iris.register.getCall(0);\n\n    t.equal(addCall.args[0].pattern, 'status.metis', 'The service exposes a status handle');\n\n    const statusImp = addCall.args[0].handler;\n    const impResultP = statusImp({});\n\n    t.ok(impResultP instanceof Promise, 'The implementation of status returns a promise');\n\n    await impResultP\n      .then((result: any) => {\n        t.deepEqual(_pack, result, 'The implementation returns what we expect');\n        t.ok(true, 'Implementation does not blow up');\n      })\n      .catch(() => {\n        t.notOk(true, 'Implementation should not blow up');\n      });\n\n    addCall = _iris.register.getCall(1);\n    t.equal(addCall.args[0].pattern, 'action.annotate.get', 'The service exposes an annotate handle');\n\n    addCall = _iris.register.getCall(2);\n    t.equal(addCall.args[0].pattern, 'action.synonyms.get', 'The service exposes a getSynonymsHandler');\n\n    addCall = _iris.register.getCall(3);\n    t.equal(addCall.args[0].pattern, 'action.synonyms.populate', 'The service exposes a populateSynonymsHandler');\n\n    addCall = _iris.register.getCall(4);\n    t.equal(addCall.args[0].pattern, 'action.synonyms.all', 'The service exposes a populateSynonymsHandler');\n\n  }\n\n  _test()\n    .then(() => t.end())\n    .catch(console.error);\n});\n",
    "static": true,
    "longname": "/Users/alexanderbrinkmann/Documents/Repositories/metis/src/service.spec.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 86,
    "kind": "file",
    "name": "src/service.ts",
    "content": "import irisSetup from '@repositive/iris';\nimport { inject } from '@repositive/iris';\n\nimport * as config from 'config';\n\nimport { get } from './Annotation/controllerAnnotate';\nimport { getSynonyms, populateSynonyms, getAllSynonyms } from './Synonyms/controllerSynonyms';\n\n\nimport { Pool } from 'pg';\n\nconst pack = require('../package.json');\n\n/**\n * @desc This function initializes Metis, so that it can respond to iris requests.\n * @param {JSON} config - Pass configuration file.\n * @param {Object} irisSetup - Pass iris setup.\n * @param {JSON} pack - Pass package.json.\n * @param {Object} Pool - Pass postgres element to work with database.\n */\nexport default async function init({\n  _config = config,\n  _irisSetup = irisSetup,\n  _pack = pack,\n  _Pool = Pool\n}: {\n    _config?: typeof config,\n    _irisSetup?: typeof irisSetup,\n    _pack?: { version: string },\n    _Pool?: typeof Pool\n  }): Promise<void> {\n  const irisOpts = _config.get<any>('iris');\n  const iris = await _irisSetup(irisOpts);\n\n  const pgOpts = _config.get<any>('db');\n  const postgres = new _Pool(pgOpts);\n  postgres.on('error', (err: Error) => {\n    console.error(err.stack);\n    process.exit(1);\n  });\n\n  iris.register({\n    pattern: 'status.metis',\n    async handler(msg: any) {\n      return {\n        name: _pack.name,\n        version: _pack.version\n      };\n    }\n  });\n\n  const _getHandler = inject({ args: { _postgres: postgres }, func: get });\n  iris.register({\n    pattern: 'action.annotate.get',\n    handler: _getHandler\n  });\n\n\n  const _getSynonymsHandler = inject({ args: { _postgres: postgres }, func: getSynonyms });\n  iris.register({\n    pattern: 'action.synonyms.get',\n    handler: _getSynonymsHandler\n  });\n\n  const _populateSynonymsHandler = inject({ args: { _postgres: postgres }, func: populateSynonyms });\n  iris.register({\n    pattern: 'action.synonyms.populate',\n    handler: _populateSynonymsHandler\n  });\n\n  const _allSynonymsHandler = inject({ args: { _postgres: postgres }, func: getAllSynonyms });\n  iris.register({\n    pattern: 'action.synonyms.all',\n    handler: _allSynonymsHandler\n  });\n}\n",
    "static": true,
    "longname": "/Users/alexanderbrinkmann/Documents/Repositories/metis/src/service.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 87,
    "kind": "variable",
    "name": "pack",
    "memberof": "src/service.ts",
    "static": true,
    "longname": "src/service.ts~pack",
    "access": "public",
    "export": false,
    "importPath": "metis/src/service.ts",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 88,
    "kind": "function",
    "name": "init",
    "memberof": "src/service.ts",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "src/service.ts~init",
    "access": "public",
    "export": true,
    "importPath": "metis/src/service.ts",
    "importStyle": "init",
    "description": "This function initializes Metis, so that it can respond to iris requests.",
    "lineNumber": 25,
    "params": [
      {
        "nullable": null,
        "types": [
          "JSON"
        ],
        "spread": false,
        "optional": false,
        "name": "config",
        "description": "Pass configuration file."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "irisSetup",
        "description": "Pass iris setup."
      },
      {
        "nullable": null,
        "types": [
          "JSON"
        ],
        "spread": false,
        "optional": false,
        "name": "pack",
        "description": "Pass package.json."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "Pool",
        "description": "Pass postgres element to work with database."
      }
    ],
    "return": {
      "types": [
        "{\"name\": *, \"version\": *}"
      ]
    }
  },
  {
    "kind": "index",
    "content": "# Metis\nMetis is the service that annotates datasets with ontology terms using the Zooma application developed by the SPOT team at EBI. Metis is also able to retrieve synonyms for an ontology term / ontology ID.\n\nMetis is named after the ancient Greek Titaness of good counsel, advice, planning, cunning, craftiness, and wisdom [[1](http://greekmythology.wikia.com/wiki/Metis), [2](https://en.wikipedia.org/wiki/Metis_(mythology))].\nIt takes a field and term and responds with ontology terms for 'assay'/'technology'/'tissue'/'disease' fields.\n\n1. [http://greekmythology.wikia.com/wiki/Metis](http://greekmythology.wikia.com/wiki/Metis)\n2. [https://en.wikipedia.org/wiki/Metis_(mythology)](https://en.wikipedia.org/wiki/Metis_(mythology))\n\n### Update Datasets with Ontology Terms\n\nMetis uses Iris to register a `action.annotate.get` pattern.\n\nThe ingestion payload must be in the [format](schemas/get-schema.json):\n```ts\ntype Payload = {\n  term: string;\n  field?: string;\n  force?: boolean;\n}\n```\n\n\nThe response is always an array of matched terms:\n\n```ts\ntype Response = [{\n  term: string; // The standard term matched\n  iri: string; // The Ontology Term IRI\n  confidence: number; // How likely it is that the match is correct\n  source: string; // The matched ontoloty URL\n  short_name: string; // The matched ontology name identifier.\n}]\n```\n\n### Update Datasets by single list of Synonyms\n\nMetis uses Iris to register a `action.synonyms.get` pattern.\n\nThe ingestion payload must be in the [format](schemas/synonyms-is-valid.json):\n```ts\ntype Payload = {\n  symbol: string;\n}\n```\n\n\nThe response is always an array of matched terms:\n\n```ts\ntype Response = [{\n  list_synonyms: string; // A list of all synonyms retrieved via HUGO\n}]\n```\n\n### Populate Datasets with Synonyms\n\nMetis uses Iris to register a `action.annotate.populate` pattern.\n\n### Return list of all lists of Synonyms\n\nMetis uses Iris to register a `action.annotate.populate` pattern.\n\n\n\n>>>>>>> origin/master\n\n## Setting up the database\n\nMetis uses postgres to store a lookup table and accelerate the process of returning existing results from previous queries. To setup the database create a new  database called `metis` and execute [`setup.sql`](setup.sql).\n\n## About Docker Compose\n\nThe current version of [Iris](https://github.com/repositive/iris-js) requires an AMQP server. The docker-compose comes preconfigured to connect to one out of the box. You'll need to run an instance yourself and attach it to the network rabbit, and to the postgres database. For this purpose please use the devops service:\n\n**Manual approach:**\n**Create the postgres network**\n```bash\n$ docker network create postgres\n```\n\n**Run a postgres process**\n```bash\n$ docker run --name=postgres --network=postgres -p 5432:5432 -d registry.repositive.io:5000/postgres-data\n```\n\n\n**Create the rabbit network**\n```bash\n$ docker network create rabbit\n```\n\n**Run a rabbitmq process**\n```bash\n$ docker run --name=rabbit --network=rabbit -p 5672:5672 -p 15672:15672 -d rabbitmq:3-management\n```\n\n\n**Use devops service to start postgres network and rabbit network:**\nOpen the devops service\n\n**Create postgres network**\n\n```bash\n$ cd development-environment/pdx/infra\n$ docker-compose up -d postgres\n```\n\n**Create rabbit network**\n\n```bash\n$ cd development-environment/pdx/infra\n$ docker-compose up -d rabbit\n```\n\nNow postgres and rabbit are running!\n\nPlease return to the metis file system.\n\nIf you run  `$ docker-compose up` now you should be able to see this service running using the iris cli `$ iris status`\n\n## Notes\n\nThe repository has a `precommit` hook that will trigger linter for each commit. You can check it in the scripts section of the `package.json`\n",
    "longname": "/Users/alexanderbrinkmann/Documents/Repositories/metis/README.md",
    "name": "./README.md",
    "static": true,
    "access": "public"
  },
  {
    "kind": "packageJSON",
    "content": "{\n  \"name\": \"metis\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"main\": \"dist/index.js\",\n  \"types\": \"dist/index.d.ts\",\n  \"files\": [\n    \"dist\"\n  ],\n  \"scripts\": {\n    \"precommit\": \"npm run lint\",\n    \"setup\": \"npm i && tsc --outDir dist\",\n    \"start\": \"node .\",\n    \"startDev\": \"nodemon --watch src/ --watch package.json -e ts,json -q -x 'rm -fr dist && echo \\\"\\\\n============\\\\nCOMPILING...\\\\n============\\\\n\\\\n\\\" && tsc --outDir dist || return 0 && node .'\",\n    \"make\": \"rm -fr dist && tsc\",\n    \"lint\": \"tslint -c tslint.json src/**/*.ts\",\n    \"test\": \"nyc --reporter lcov tape $(find dist -name '*.spec.js' ! -name 'index.js') | tap-spec\",\n    \"coverage\": \"nyc check-coverage --lines 70 --functions 70 --branches 60\",\n    \"documentation\": \"./node_modules/.bin/esdoc\"\n  },\n  \"nyc\": {\n    \"extension\": [\n      \".ts\",\n      \".tsx\"\n    ],\n    \"exclude\": [\n      \"**/*.spec.js\",\n      \"**/*.d.ts\"\n    ]\n  },\n  \"esdoc\": {\n    \"source\": \"./src\",\n    \"destination\": \"./docs\",\n    \"plugins\": [\n      {\n        \"name\": \"esdoc-standard-plugin\",\n        \"option\": {\n          \"brand\": {\n            \"logo\": \"./logo.png\",\n            \"title\": \"Metis\",\n            \"description\": \"Metis Documentation\",\n            \"repository\": \"https://github.com/repositive/metis/\",\n            \"image\": \"./logo.png\"\n          },\n          \"test\": {\n            \"source\": \"./dist\",\n            \"interfaces\": [\"describe\", \"it\", \"context\", \"suite\", \"test\"],\n            \"includes\": [\"(spec|Spec|test|Test)\\\\.js$\"]\n          }\n        }\n        \n      },\n      {\n        \"name\": \"esdoc-typescript-plugin\",\n        \"option\": {\n          \"enable\": true\n        }\n      }\n    ]\n  },\n  \"author\": \"Repositive Team\",\n  \"license\": \"MIT\",\n  \"keywords\": [\n    \"metis\",\n    \"service\"\n  ],\n  \"dependencies\": {\n    \"@repositive/iris\": \"^0.7.6\",\n    \"ajv\": \"^5.2.2\",\n    \"config\": \"^1.26.2\",\n    \"node-fetch\": \"^1.7.2\",\n    \"pg\": \"^7.3.0\",\n    \"ramda\": \"^0.24.1\",\n    \"request\": \"^2.81.0\",\n    \"request-promise\": \"^4.2.1\"\n  },\n  \"devDependencies\": {\n    \"@repositive/typescript\": \"^1.1.2\",\n    \"@types/config\": \"0.0.32\",\n    \"@types/node\": \"^8.0.24\",\n    \"@types/pg\": \"^7.1.4\",\n    \"@types/proxyquire\": \"^1.3.28\",\n    \"@types/ramda\": \"^0.24.13\",\n    \"@types/request-promise\": \"^4.1.37\",\n    \"@types/sinon\": \"^2.3.3\",\n    \"@types/tape\": \"^4.2.30\",\n    \"esdoc\": \"^1.0.4\",\n    \"esdoc-standard-plugin\": \"^1.0.0\",\n    \"esdoc-typescript-plugin\": \"^1.0.0\",\n    \"husky\": \"^0.14.3\",\n    \"nodemon\": \"^1.11.0\",\n    \"nyc\": \"^11.1.0\",\n    \"proxyquire\": \"^1.8.0\",\n    \"sinon\": \"^3.2.1\",\n    \"tap-spec\": \"^4.1.1\",\n    \"tape\": \"^4.8.0\",\n    \"tslint\": \"^5.6.0\",\n    \"typescript\": \"^2.4.2\"\n  }\n}\n",
    "longname": "/Users/alexanderbrinkmann/Documents/Repositories/metis/package.json",
    "name": "package.json",
    "static": true,
    "access": "public"
  },
  {
    "__docId__": 89,
    "kind": "testFile",
    "name": "dist/Annotation/annotate-schema.spec.js",
    "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst test = require(\"tape\");\nconst Ajv = require(\"ajv\");\nconst fs = require(\"fs\");\n//--------------------------\nconst schemas = [\n    JSON.parse(fs.readFileSync('./schemas/get-schema.json', 'utf8'))\n];\nconst ajv = new Ajv({ allErrors: true, verbose: true, schemas });\ntest('The schemas are valid', (t) => {\n    schemas.forEach((item) => {\n        const schema = ajv.getSchema(item.id);\n        t.ok(schema !== undefined, `Schema ${item.id} loads`);\n    });\n    t.end();\n});\ntest('Term is required for get function', (t) => {\n    const schema = ajv.getSchema('get-schema.json');\n    const json = { field: 'abc' };\n    const valid = schema(json);\n    t.notOk(valid, 'Object without term is not valid payload');\n    t.ok(schema.errors, `There are errors in ingestion-schema.json`);\n    if (schema.errors) {\n        t.equals(schema.errors[0]['message'], 'should have required property \\'term\\'', 'Correct error message');\n    }\n    t.end();\n});\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYW5ub3RhdGUtc2NoZW1hLnNwZWMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvQW5ub3RhdGlvbi9hbm5vdGF0ZS1zY2hlbWEuc3BlYy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLDZCQUE2QjtBQUU3QiwyQkFBMkI7QUFDM0IseUJBQXlCO0FBRXpCLDRCQUE0QjtBQUU1QixNQUFNLE9BQU8sR0FBVTtJQUNyQixJQUFJLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxZQUFZLENBQUMsMkJBQTJCLEVBQUUsTUFBTSxDQUFDLENBQUM7Q0FDakUsQ0FBQztBQUVGLE1BQU0sR0FBRyxHQUFHLElBQUksR0FBRyxDQUFDLEVBQUUsU0FBUyxFQUFFLElBQUksRUFBRSxPQUFPLEVBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRSxDQUFDLENBQUM7QUFFakUsSUFBSSxDQUFDLHVCQUF1QixFQUFFLENBQUMsQ0FBTyxFQUFFLEVBQUU7SUFDeEMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxDQUFDLElBQUksRUFBRSxFQUFFO1FBQ3ZCLE1BQU0sTUFBTSxHQUFHLEdBQUcsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQ3RDLENBQUMsQ0FBQyxFQUFFLENBQUMsTUFBTSxLQUFLLFNBQVMsRUFBRSxVQUFVLElBQUksQ0FBQyxFQUFFLFFBQVEsQ0FBQyxDQUFDO0lBQ3hELENBQUMsQ0FBQyxDQUFDO0lBQ0gsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDO0FBQ1YsQ0FBQyxDQUFDLENBQUM7QUFFSCxJQUFJLENBQUMsbUNBQW1DLEVBQUUsQ0FBQyxDQUFPLEVBQUUsRUFBRTtJQUNwRCxNQUFNLE1BQU0sR0FBRyxHQUFHLENBQUMsU0FBUyxDQUFDLGlCQUFpQixDQUFDLENBQUM7SUFDaEQsTUFBTSxJQUFJLEdBQUcsRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLENBQUM7SUFDOUIsTUFBTSxLQUFLLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQzNCLENBQUMsQ0FBQyxLQUFLLENBQUMsS0FBSyxFQUFFLDBDQUEwQyxDQUFDLENBQUM7SUFDM0QsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxNQUFNLENBQUMsTUFBTSxFQUFFLDJDQUEyQyxDQUFDLENBQUM7SUFDakUsRUFBRSxDQUFDLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7UUFDbEIsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxFQUFFLHdDQUF3QyxFQUFFLHVCQUF1QixDQUFDLENBQUM7SUFDM0csQ0FBQztJQUNELENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQztBQUNWLENBQUMsQ0FBQyxDQUFDIn0=",
    "static": true,
    "longname": "/Users/alexanderbrinkmann/Documents/Repositories/metis/dist/Annotation/annotate-schema.spec.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 90,
    "kind": "test",
    "name": "test0",
    "testId": 0,
    "memberof": "dist/Annotation/annotate-schema.spec.js",
    "testDepth": 0,
    "static": true,
    "longname": "dist/Annotation/annotate-schema.spec.js~test0",
    "access": null,
    "description": "The schemas are valid",
    "lineNumber": 11
  },
  {
    "__docId__": 91,
    "kind": "test",
    "name": "test1",
    "testId": 1,
    "memberof": "dist/Annotation/annotate-schema.spec.js",
    "testDepth": 0,
    "static": true,
    "longname": "dist/Annotation/annotate-schema.spec.js~test1",
    "access": null,
    "description": "Term is required for get function",
    "lineNumber": 18
  },
  {
    "__docId__": 92,
    "kind": "testFile",
    "name": "dist/Annotation/annotate.spec.js",
    "content": "\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst test = require(\"tape\");\nconst sinon_1 = require(\"sinon\");\nconst proxyquire = require(\"proxyquire\");\nconst fs = require(\"fs\");\n//-------------------------------\ntest('Testing Zooma annotate service', (t) => {\n    t.test('The term is successfully matched', function (st) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const field = 'assay';\n            const term = 'WXS';\n            const annotateResult = [{\n                    term: 'random exon sequencing',\n                    iri: 'http://www.ebi.ac.uk/efo/EFO_0003746',\n                    confidence: 0.6,\n                    source: 'http://www.ebi.ac.uk/efo/efo.owl',\n                    short_name: 'efo'\n                }];\n            const requestResponse = JSON.parse(fs.readFileSync('./assets/testAnnotateResponse.json', 'utf8'));\n            const mockedReq = sinon_1.stub().returns(Promise.resolve([requestResponse]));\n            const _annotate = proxyquire('./annotate', {\n                'request-promise': mockedReq\n            });\n            st.equals(typeof _annotate.default, 'function', 'The module exports a function called annotate');\n            const result = yield _annotate.default({ payload: { field, term } })\n                .then(function (data) {\n                //console.log('got data', data);\n                return data;\n            }).catch((err) => {\n                console.error(err);\n                console.log('annotate error');\n                // API call failed...\n                st.notOk(err, 'There is an error');\n            });\n            st.assert(mockedReq.called, 'It calls request');\n            st.equal(mockedReq.callCount, 1, 'It calls request once');\n            st.assert(result instanceof Object, 'Returns an object');\n            st.assert(('term' in result[0]), 'Result has ontologyTerm');\n            st.deepEquals(result, annotateResult, 'The final result is equal to the expected result');\n            st.end();\n        });\n    });\n    t.test('The shortname is the accession prefix', function (st) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const field = 'disease';\n            const term = 'abc';\n            const annotateResult = [{\n                    term: 'abc disease',\n                    iri: 'http://www.test.net/abc/ABCDE_166',\n                    confidence: 0.8,\n                    source: 'https://www.test',\n                    short_name: 'abcde'\n                }];\n            const requestResponse = {\n                'annotatedProperty': { 'propertyValue': 'abc disease' },\n                '_links': { 'olslinks': [{ 'semanticTag': 'http://www.test.net/abc/ABCDE_166' }] },\n                'derivedFrom': { 'provenance': { 'source': { 'uri': 'https://www.test' } } },\n                'confidence': 0.8\n            };\n            const mockedReq = sinon_1.stub().returns(Promise.resolve([requestResponse]));\n            const _annotate = proxyquire('./annotate', { 'request-promise': mockedReq });\n            const result = yield _annotate.default({ payload: { field, term } })\n                .then(function (data) {\n                return data;\n            }).catch((err) => {\n                console.error(err);\n            });\n            st.assert(typeof result[0].short_name === 'string', 'Ontology shortname is a string');\n            st.deepEquals(result[0].short_name, annotateResult[0].short_name, 'The shortname is equal to the accession prefix');\n            st.end();\n        });\n    });\n    t.test('The shortname is correct when the accession prefix is unusual', function (st) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const field = 'disease';\n            const term = 'abc';\n            const annotateResult = [{\n                    term: 'abc disease',\n                    iri: 'http://www.test.net/abc/topic_166',\n                    confidence: 0.8,\n                    source: 'https://www.test',\n                    short_name: 'edam'\n                }];\n            const requestResponse = {\n                'annotatedProperty': { 'propertyValue': 'abc disease' },\n                '_links': { 'olslinks': [{ 'semanticTag': 'http://www.test.net/abc/topic_166' }] },\n                'derivedFrom': { 'provenance': { 'source': { 'uri': 'https://www.test' } } },\n                'confidence': 0.8\n            };\n            const mockedReq = sinon_1.stub().returns(Promise.resolve([requestResponse]));\n            const _annotate = proxyquire('./annotate', { 'request-promise': mockedReq });\n            const result = yield _annotate.default({ payload: { field, term } })\n                .then(function (data) {\n                return data;\n            }).catch((err) => {\n                console.error(err);\n            });\n            st.assert(typeof result[0].short_name === 'string', 'Ontology shortname is a string');\n            st.deepEquals(result[0].short_name, annotateResult[0].short_name, 'The shortname is correct');\n            st.end();\n        });\n    });\n    t.test('The shortname is correct when the accession prefix is Orphanet', function (st) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const field = 'disease';\n            const term = 'abc';\n            const annotateResult = [{\n                    term: 'abc disease',\n                    iri: 'http://www.test.net/abc/Orphanet_166',\n                    confidence: 0.8,\n                    source: 'https://www.test',\n                    short_name: 'ordo'\n                }];\n            const requestResponse = {\n                'annotatedProperty': { 'propertyValue': 'abc disease' },\n                '_links': { 'olslinks': [{ 'semanticTag': 'http://www.test.net/abc/Orphanet_166' }] },\n                'derivedFrom': { 'provenance': { 'source': { 'uri': 'https://www.test' } } },\n                'confidence': 0.8\n            };\n            const mockedReq = sinon_1.stub().returns(Promise.resolve([requestResponse]));\n            const _annotate = proxyquire('./annotate', { 'request-promise': mockedReq });\n            const result = yield _annotate.default({ payload: { field, term } })\n                .then(function (data) {\n                return data;\n            }).catch((err) => {\n                console.error(err);\n            });\n            st.assert(typeof result[0].short_name === 'string', 'Ontology shortname is a string');\n            st.deepEquals(result[0].short_name, annotateResult[0].short_name, 'The shortname is correct');\n            st.end();\n        });\n    });\n    t.test('An unknown term is not matched', function (st) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const field = 'tissue';\n            const term = 'viiat';\n            const annotateResult = [];\n            const requestResponse = undefined;\n            const mockedReq = sinon_1.stub().returns(Promise.resolve([requestResponse]));\n            const _annotate = proxyquire('./annotate', {\n                'request-promise': mockedReq\n            });\n            st.equals(typeof _annotate.default, 'function', 'The module exports a function called annotate');\n            const result = yield _annotate.default({ payload: { field, term } })\n                .then(function (data) {\n                //console.log('got data', data);\n                return data;\n            }).catch((err) => {\n                console.error(err);\n                console.log('annotate error - API call failed...');\n                st.notOk(err, 'There is an error');\n            });\n            st.ok(mockedReq.called, 'It calls request');\n            st.equal(mockedReq.callCount, 1, 'It calls request once');\n            st.assert(Array.isArray(result) && result.length === 0, 'Returns an empty array');\n            st.deepEquals(result, annotateResult, 'The final result is equal to the expected result');\n            st.end();\n        });\n    });\n    t.test('If term is \\'undefined\\' there is an error', function (st) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const field = 'tissue';\n            const term = undefined;\n            const annotateResult = [];\n            const requestResponse = {};\n            const mockedReq = sinon_1.stub().returns(Promise.resolve([requestResponse]));\n            const _annotate = proxyquire('./annotate', {\n                'request-promise': mockedReq\n            });\n            st.equals(typeof _annotate.default, 'function', 'The module exports a function called annotate');\n            const result = yield _annotate.default({ payload: { field, term } })\n                .then(function (data) {\n                return data;\n            }).catch((err) => {\n                st.ok(err, 'There is an error');\n            });\n            st.ok(mockedReq.notCalled, 'It doesn\\'t call request function');\n            st.deepEquals(result, annotateResult, 'Returns an empty array');\n            st.end();\n        });\n    });\n    t.test('If term is \\'none\\' there is no error and no matching', function (st) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const field = 'tissue';\n            const term = 'none';\n            const annotateResult = [];\n            const requestResponse = {};\n            const mockedReq = sinon_1.stub().returns(Promise.resolve([requestResponse]));\n            const _annotate = proxyquire('./annotate', {\n                'request-promise': mockedReq\n            });\n            st.equals(typeof _annotate.default, 'function', 'The module exports a function called annotate');\n            const result = yield _annotate.default({ payload: { field, term } })\n                .then(function (data) {\n                //console.log('got data', data);\n                return data;\n            }).catch((err) => {\n                console.error(err);\n                console.log('annotate error');\n                // API call failed...\n                st.notOk(err, 'There is an error');\n            });\n            st.ok(mockedReq.notCalled, 'It doesn\\'t call request function');\n            st.assert(Array.isArray(result) && result.length === 0, 'Returns an empty array');\n            st.deepEquals(result, annotateResult, 'The final result is equal to the expected result');\n            st.end();\n        });\n    });\n    t.test('Request errors throw a new error', function (st) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const field = 'tissue';\n            const term = 'abc';\n            const mockedReq = sinon_1.stub().returns(Promise.reject(new Error('fail')));\n            const _annotate = proxyquire('./annotate', {\n                'request-promise': mockedReq\n            });\n            const result = yield _annotate.default({ payload: { field, term } })\n                .then(function (data) {\n                return data;\n            }).catch((err) => {\n                st.assert(err, 'There is an error from the request');\n            });\n            st.end();\n        });\n    });\n    t.end();\n});\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYW5ub3RhdGUuc3BlYy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9Bbm5vdGF0aW9uL2Fubm90YXRlLnNwZWMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBLDZCQUE2QjtBQUU3QixpQ0FBNkI7QUFDN0IseUNBQXlDO0FBQ3pDLHlCQUF5QjtBQUV6QixpQ0FBaUM7QUFFakMsSUFBSSxDQUFDLGdDQUFnQyxFQUFFLENBQUMsQ0FBTyxFQUFFLEVBQUU7SUFDakQsQ0FBQyxDQUFDLElBQUksQ0FBQyxrQ0FBa0MsRUFBRSxVQUFnQixFQUFROztZQUVqRSxNQUFNLEtBQUssR0FBRyxPQUFPLENBQUM7WUFDdEIsTUFBTSxJQUFJLEdBQUcsS0FBSyxDQUFDO1lBRW5CLE1BQU0sY0FBYyxHQUFHLENBQUM7b0JBQ3RCLElBQUksRUFBRSx3QkFBd0I7b0JBQzlCLEdBQUcsRUFBRSxzQ0FBc0M7b0JBQzNDLFVBQVUsRUFBRSxHQUFHO29CQUNmLE1BQU0sRUFBRSxrQ0FBa0M7b0JBQzFDLFVBQVUsRUFBRSxLQUFLO2lCQUNsQixDQUFDLENBQUM7WUFFSCxNQUFNLGVBQWUsR0FBUSxJQUFJLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxZQUFZLENBQUMsb0NBQW9DLEVBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQztZQUV2RyxNQUFNLFNBQVMsR0FBRyxZQUFJLEVBQUUsQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxDQUFDLGVBQWUsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUVyRSxNQUFNLFNBQVMsR0FBRyxVQUFVLENBQUMsWUFBWSxFQUFFO2dCQUN6QyxpQkFBaUIsRUFBRSxTQUFTO2FBQzdCLENBQUMsQ0FBQztZQUVILEVBQUUsQ0FBQyxNQUFNLENBQUMsT0FBTyxTQUFTLENBQUMsT0FBTyxFQUFFLFVBQVUsRUFBRSwrQ0FBK0MsQ0FBQyxDQUFDO1lBRWpHLE1BQU0sTUFBTSxHQUFHLE1BQU0sU0FBUyxD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",
    "static": true,
    "longname": "/Users/alexanderbrinkmann/Documents/Repositories/metis/dist/Annotation/annotate.spec.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 93,
    "kind": "test",
    "name": "test2",
    "testId": 2,
    "memberof": "dist/Annotation/annotate.spec.js",
    "testDepth": 0,
    "static": true,
    "longname": "dist/Annotation/annotate.spec.js~test2",
    "access": null,
    "description": "Testing Zooma annotate service",
    "lineNumber": 16
  },
  {
    "__docId__": 94,
    "kind": "testFile",
    "name": "dist/Annotation/controllerAnnotate.spec.js",
    "content": "\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst test = require(\"tape\");\nconst sinon_1 = require(\"sinon\");\nconst fs = require(\"fs\");\nconst Ajv = require(\"ajv\");\nconst controllerAnnotate_1 = require(\"./controllerAnnotate\");\n//-------------------------------\ntest('Testing Annotation controller', (t) => {\n    t.test('Test get function when term is in database', function (st) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const _postgres = {};\n            const payload = { field: 'abc', term: 'test' };\n            const _ajv = new Ajv();\n            const validateStub = sinon_1.stub(_ajv, 'validate').returns(true);\n            const _schema = sinon_1.stub();\n            const mockResult = [{\n                    'ontology_uid': 26,\n                    'confidence': 0.6,\n                    'ontology_uri': 'http://www.test.ac.uk/TEST_0005016',\n                    'ontology_term': 'test',\n                    'source_uri': 'https://www.test.ac.uk/test',\n                    'short_name': 'test'\n                }];\n            const _selectFromDb = sinon_1.stub().returns(Promise.resolve(mockResult));\n            const _getAnnotation = sinon_1.stub().returns(Promise.resolve());\n            const result = yield controllerAnnotate_1.get({ payload, _postgres, _ajv, _getAnnotation, _schema, _selectFromDb })\n                .catch((err) => {\n                st.notOk(err, 'Function should not error');\n            });\n            st.assert(_ajv.validate.called, 'It calls validate once');\n            st.assert(_selectFromDb.calledOnce, 'It calls _selectFromDb');\n            st.equals(_selectFromDb.getCall(0).args[0]._term, 'test', 'SelectFromDb is called with the correct term');\n            st.deepEquals(result, mockResult, 'It returns the expected result');\n            st.end();\n        });\n    });\n    t.test('If the schema is not valid, throws an error', function (st) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const _postgres = {};\n            const payload = { field: 'abc', term: 'test' };\n            const _ajv = new Ajv();\n            const validateStub = sinon_1.stub(_ajv, 'validate').returns(false);\n            const _schema = JSON.parse(fs.readFileSync('./schemas/get-schema.json', 'utf8'));\n            const mockResult = {\n                'ontology_uid': 26,\n                'confidence': 0.6,\n                'ontology_uri': 'http://www.test.ac.uk/TEST_0005016',\n                'ontology_term': 'test',\n                'source_uri': 'https://www.test.ac.uk/test',\n                'short_name': 'test'\n            };\n            const _selectFromDb = sinon_1.stub().returns(Promise.resolve(mockResult));\n            const _getAnnotation = sinon_1.stub().returns(Promise.resolve());\n            const result = yield controllerAnnotate_1.get({ payload, _postgres, _ajv, _getAnnotation, _schema, _selectFromDb })\n                .catch((err) => {\n                st.ok(err, 'Function should throw error');\n            });\n            st.assert(_ajv.validate.calledOnce, 'It calls validate once');\n            st.deepEquals(_ajv.validate.getCall(0).args, [_schema, payload], 'It calls validate with correct args');\n            st.assert(_selectFromDb.notCalled, 'SelectFromDb is not called');\n            st.end();\n        });\n    });\n    t.test('Test get function when term is not in database', function (st) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const _postgres = {};\n            const payload = { field: 'abc', term: 'test' };\n            const _ajv = new Ajv();\n            const validateStub = sinon_1.stub(_ajv, 'validate').returns(true);\n            const _schema = sinon_1.stub();\n            const mockResult = [{\n                    'ontology_uid': 26,\n                    'confidence': 0.6,\n                    'ontology_uri': 'http://www.test.ac.uk/TEST_0005016',\n                    'ontology_term': 'test',\n                    'source_uri': 'https://www.test.ac.uk/test',\n                    'short_name': 'test'\n                }];\n            const _selectFromDb = sinon_1.stub()\n                .onFirstCall().returns(Promise.resolve([undefined]))\n                .onSecondCall().returns(Promise.resolve(mockResult));\n            const _getAnnotation = sinon_1.stub().returns(Promise.resolve());\n            const result = yield controllerAnnotate_1.get({ payload, _postgres, _ajv, _getAnnotation, _schema, _selectFromDb })\n                .catch((err) => {\n                st.notOk(err, 'Function should not error');\n            });\n            st.assert(_selectFromDb.calledTwice, 'It calls selectFromDb twice');\n            st.equals(_selectFromDb.getCall(0).args[0]._term, 'test', 'selectFromDb is called with the correct term');\n            st.deepEquals(_getAnnotation.getCall(0).args[0].payload, payload, 'getAnnotation is called with the correct payload');\n            st.equals(_selectFromDb.getCall(1).args[0]._term, 'test', 'selectFromDb is called again with the correct term');\n            st.equals(result, mockResult, 'It returns the expected result');\n            st.end();\n        });\n    });\n    t.test('Test selectFromDb', function (st) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const mockResult = {\n                otherKey: 'other',\n                rows: [{\n                        'ontology_uid': 26,\n                        'confidence': 0.6,\n                        'ontology_uri': 'http://www.test.ac.uk/TEST_0005016',\n                        'ontology_term': 'test',\n                        'source_uri': 'https://www.test.ac.uk/test',\n                        'short_name': 'test'\n                    }]\n            };\n            const expectedResult = [{\n                    'ontology_uid': 26,\n                    'confidence': 0.6,\n                    'ontology_uri': 'http://www.test.ac.uk/TEST_0005016',\n                    'ontology_term': 'test',\n                    'source_uri': 'https://www.test.ac.uk/test',\n                    'short_name': 'test'\n                }];\n            const _postgres = { query: sinon_1.stub().returns(Promise.resolve(mockResult)) };\n            const _term = 'test';\n            const result = yield controllerAnnotate_1.selectFromDb({ _postgres, _term })\n                .catch((err) => {\n                st.notOk(err, 'Function should not error');\n            });\n            st.assert(_postgres.query.calledOnce, 'Query postgres once');\n            st.deepEquals(result, expectedResult, 'It returns the expected result');\n            st.end();\n        });\n    });\n    t.test('Test getAnnotation', function (st) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const mockResultArray = [{\n                    term: 'test',\n                    iri: 'http://www.test.ac.uk/TEST_0005016',\n                    confidence: 0.75,\n                    source: 'https://www.test.ac.uk/test',\n                    short_name: 'test'\n                }];\n            const mockResultObj = mockResultArray[0];\n            const mockOntology_uid = 5;\n            const query = sinon_1.stub()\n                .onFirstCall().returns(Promise.resolve({ rows: [{ id: mockOntology_uid }] }))\n                .onSecondCall().returns(Promise.resolve(mockResultObj));\n            const _postgres = { query };\n            const payload = { field: 'abc', term: 'test' };\n            const _annotate = sinon_1.stub().returns(Promise.resolve(mockResultArray));\n            const result = yield controllerAnnotate_1.getAnnotation({ payload, _postgres, _annotate })\n                .catch((err) => {\n                st.notOk(err, 'Function should not error');\n            });\n            st.equals(_annotate.getCall(0).args[0].payload, payload, 'Calls annotate with correct payload');\n            st.equals(_postgres.query.callCount, 2, 'Postgres query called correct number of times');\n            st.deepEquals(_postgres.query.getCall(0).args[0].values, [mockResultObj.iri, mockResultObj.term, mockResultObj.source, mockResultObj.short_name], 'First query made inserts ontology term');\n            st.deepEquals(_postgres.query.getCall(1).args[0].values, [payload.term, mockOntology_uid, mockResultObj.confidence], 'Second query is to insert the original term');\n            st.end();\n        });\n    });\n    t.end();\n});\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29udHJvbGxlckFubm90YXRlLnNwZWMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvQW5ub3RhdGlvbi9jb250cm9sbGVyQW5ub3RhdGUuc3BlYy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUEsNkJBQTZCO0FBRTdCLGlDQUE2QjtBQUU3Qix5QkFBeUI7QUFDekIsMkJBQTJCO0FBRTNCLDZEQUF3RTtBQUV4RSxpQ0FBaUM7QUFFakMsSUFBSSxDQUFDLCtCQUErQixFQUFFLENBQUMsQ0FBTyxFQUFFLEVBQUU7SUFDaEQsQ0FBQyxDQUFDLElBQUksQ0FBQyw0Q0FBNEMsRUFBRSxVQUFnQixFQUFROztZQUUzRSxNQUFNLFNBQVMsR0FBUSxFQUFFLENBQUM7WUFDMUIsTUFBTSxPQUFPLEdBQUcsRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLElBQUksRUFBRSxNQUFNLEVBQUUsQ0FBQztZQUMvQyxNQUFNLElBQUksR0FBUSxJQUFJLEdBQUcsRUFBRSxDQUFDO1lBQzVCLE1BQU0sWUFBWSxHQUFHLFlBQUksQ0FBQyxJQUFJLEVBQUUsVUFBVSxDQUFDLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO1lBQzFELE1BQU0sT0FBTyxHQUFHLFlBQUksRUFBRSxDQUFDO1lBQ3ZCLE1BQU0sVUFBVSxHQUFHLENBQUM7b0JBQ2xCLGNBQWMsRUFBRSxFQUFFO29CQUNsQixZQUFZLEVBQUUsR0FBRztvQkFDakIsY0FBYyxFQUFFLG9DQUFvQztvQkFDcEQsZUFBZSxFQUFFLE1BQU07b0JBQ3ZCLFlBQVksRUFBRSw2QkFBNkI7b0JBQzNDLFlBQVksRUFBRSxNQUFNO2lCQUNyQixDQUFDLENBQUM7WUFDSCxNQUFNLGFBQWEsR0FBRyxZQUFJLEVBQUUsQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDO1lBQ2xFLE1BQU0sY0FBYyxHQUFHLFlBQUksRUFBRSxDQUFDLE9BQU8s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",
    "static": true,
    "longname": "/Users/alexanderbrinkmann/Documents/Repositories/metis/dist/Annotation/controllerAnnotate.spec.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 95,
    "kind": "test",
    "name": "test3",
    "testId": 3,
    "memberof": "dist/Annotation/controllerAnnotate.spec.js",
    "testDepth": 0,
    "static": true,
    "longname": "dist/Annotation/controllerAnnotate.spec.js~test3",
    "access": null,
    "description": "Testing Annotation controller",
    "lineNumber": 17
  },
  {
    "__docId__": 96,
    "kind": "testFile",
    "name": "dist/Synonyms/controllerSynonyms.spec.js",
    "content": "\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst test = require(\"tape\");\nconst sinon_1 = require(\"sinon\");\nconst Ajv = require(\"ajv\");\nconst controllerSynonyms_1 = require(\"./controllerSynonyms\");\ntest('Testing Synonyms controller', (t) => {\n    t.test('Test get function when symbol and synonyms list are in database', function (st) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const _postgres = { query: sinon_1.stub().returns(Promise.resolve()) };\n            const payload = { symbol: 'ERBB2' };\n            const _ajv = new Ajv();\n            const validateStub = sinon_1.stub(_ajv, 'validate').returns(true);\n            const _schema = sinon_1.stub();\n            const mockResult = [{\n                    'list_synonyms': '[\\\"ERBB2\\\",\\\"NEU\\\",\\\"HER-2\\\",\\\"CD340\\\",\\\"HER2\\\"]'\n                }];\n            const _selectSynonymsFromDb = sinon_1.stub().returns(Promise.resolve(mockResult));\n            const mockResultSynonyms = ['ERBB2', 'NEU', 'HER-2', 'CD340', 'HER2'];\n            const _synonyms = sinon_1.stub().returns(Promise.resolve(mockResultSynonyms));\n            const result = yield controllerSynonyms_1.getSynonyms({ payload, _postgres, _selectSynonymsFromDb, _synonyms, _ajv, _schema })\n                .catch((err) => {\n                st.notOk(err, 'Function should not error');\n            });\n            st.assert(_ajv.validate.called, 'It calls validate once');\n            st.assert(_selectSynonymsFromDb.calledOnce, 'It calls _selectSynonymsFromDb');\n            st.false(_synonyms.calledOnce, 'It does not call _synonyms');\n            st.equals(_selectSynonymsFromDb.getCall(0).args[0]._symbol, 'ERBB2', '_selectSynonymsFromDb is called with the correct symbol');\n            st.deepEquals(result, mockResult, 'It returns the expected result');\n            st.end();\n        });\n    });\n    t.test('Test getSynonyms function when term is not in database and not available by HUGO', function (st) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const _postgres = {};\n            const payload = { symbol: '1234' };\n            const _ajv = new Ajv();\n            const validateStub = sinon_1.stub(_ajv, 'validate').returns(true);\n            const _schema = sinon_1.stub();\n            const mockResult = [];\n            const _selectSynonymsFromDb = sinon_1.stub().returns(Promise.resolve(mockResult));\n            const mockResultSynonyms = [];\n            const _synonyms = sinon_1.stub().returns(Promise.resolve(mockResultSynonyms));\n            const result = yield controllerSynonyms_1.getSynonyms({ payload, _postgres, _selectSynonymsFromDb, _synonyms, _ajv, _schema })\n                .catch((err) => {\n                st.notOk(err, 'Function should not error');\n            });\n            st.assert(_selectSynonymsFromDb.calledTwice, 'It calls selectFromDb twice');\n            st.equals(_selectSynonymsFromDb.getCall(0).args[0]._symbol, '1234', 'selectFromDb is called with the correct term');\n            st.assert(_synonyms.calledOnce, 'It calls synonyms');\n            st.equals(_synonyms.getCall(0).args[0].payload.symbol, '1234', 'synonyms is called again with the correct term');\n            st.equals(_selectSynonymsFromDb.getCall(1).args[0]._symbol, '1234', 'selectFromDb is called again with the correct term');\n            st.same(result, mockResult, 'It returns the expected result');\n            st.end();\n        });\n    });\n    t.test('Test getAllSynonyms', function (st) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const _postgres = {};\n            const mockResult = [{\n                    'last_update': '123',\n                    'list_synonyms': '[\\\"ERBB2\\\",\\\"NEU\\\",\\\"HER-2\\\",\\\"CD340\\\",\\\"HER2\\\"]'\n                },\n                {\n                    'last_update': '456',\n                    'list_synonyms': '[\\\"ERBB2\\\",\\\"NEU\\\",\\\"HER-2\\\"]'\n                }];\n            const expectedResult = [\n                ['[\"ERBB2\",\"NEU\",\"HER-2\",\"CD340\",\"HER2\"]'], ['[\"ERBB2\",\"NEU\",\"HER-2\"]']\n            ];\n            const _selectAllSynonymsFromDb = sinon_1.stub().returns(Promise.resolve(mockResult));\n            const result = yield controllerSynonyms_1.getAllSynonyms({ _postgres, _selectAllSynonymsFromDb })\n                .catch((err) => {\n                st.notOk(err, 'Function should not error');\n            });\n            st.assert((_selectAllSynonymsFromDb).calledOnce, 'Trigger postgres call once');\n            st.deepEquals(result, expectedResult, 'It returns the expected result');\n            st.end();\n        });\n    });\n    t.test('Test selectAllSynonymsFromDb', function (st) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const mockResult = {\n                rows: [{\n                        'last_update': '123',\n                        'list_synonyms': '[\\\"ERBB2\\\",\\\"NEU\\\",\\\"HER-2\\\",\\\"CD340\\\",\\\"HER2\\\"]'\n                    },\n                    {\n                        'last_update': '456',\n                        'list_synonyms': '[\\\"ERBB2\\\",\\\"NEU\\\",\\\"HER-2\\\"]'\n                    }]\n            };\n            const expectedResult = [{\n                    'last_update': '123',\n                    'list_synonyms': '[\\\"ERBB2\\\",\\\"NEU\\\",\\\"HER-2\\\",\\\"CD340\\\",\\\"HER2\\\"]'\n                },\n                {\n                    'last_update': '456',\n                    'list_synonyms': '[\\\"ERBB2\\\",\\\"NEU\\\",\\\"HER-2\\\"]'\n                }];\n            const _postgres = { query: sinon_1.stub().returns(Promise.resolve(mockResult)) };\n            const result = yield controllerSynonyms_1.selectAllSynonymsFromDb({ _postgres })\n                .catch((err) => {\n                st.notOk(err, 'Function should not error');\n            });\n            st.assert(_postgres.query.calledOnce, 'Query postgres once');\n            st.deepEquals(result, expectedResult, 'It returns the expected result');\n            st.end();\n        });\n    });\n    t.test('Test selectSynonymsFromDb', function (st) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const _symbol = 'ERBB2';\n            const mockResult = {\n                rows: [{\n                        'last_update': '123',\n                        'list_synonyms': '[\\\"ERBB2\\\",\\\"NEU\\\",\\\"HER-2\\\",\\\"CD340\\\",\\\"HER2\\\"]'\n                    },\n                    {\n                        'last_update': '456',\n                        'list_synonyms': '[\\\"ERBB2\\\",\\\"NEU\\\",\\\"HER-2\\\"]'\n                    }]\n            };\n            const expectedResult = [{\n                    'last_update': '123',\n                    'list_synonyms': '[\\\"ERBB2\\\",\\\"NEU\\\",\\\"HER-2\\\",\\\"CD340\\\",\\\"HER2\\\"]'\n                },\n                {\n                    'last_update': '456',\n                    'list_synonyms': '[\\\"ERBB2\\\",\\\"NEU\\\",\\\"HER-2\\\"]'\n                }];\n            const _postgres = { query: sinon_1.stub().returns(Promise.resolve(mockResult)) };\n            const result = yield controllerSynonyms_1.selectSynonymsFromDb({ _postgres, _symbol })\n                .catch((err) => {\n                st.notOk(err, 'Function should not error');\n            });\n            st.assert(_postgres.query.calledOnce, 'Query postgres once');\n            st.deepEquals(result, expectedResult, 'It returns the expected result');\n            st.end();\n        });\n    });\n    t.test('Test populateSynonyms', function (st) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const _postgres = { query: sinon_1.stub().returns(Promise.resolve()) };\n            const mockResult = [['A1BG-AS1', 'FLJ23569'],\n                ['A1CF', 'ACF', 'ASP', 'ACF64', 'ACF65', 'APOBEC1CF'],\n                ['A2M', 'FWP007', 'S863-7', 'CPAMD5'],\n                ['ABAT', 'GABAT'],\n                ['ABCA1', 'TGD']];\n            const _allSynonyms = sinon_1.stub().returns(Promise.resolve(mockResult));\n            yield controllerSynonyms_1.populateSynonyms({ _postgres, _allSynonyms })\n                .catch(function (e) {\n                st.ok(e, 'TypeError: Cannot read property \\'0\\' of undefined');\n            });\n            st.ok(_postgres.query.called, 'true');\n            st.end();\n        });\n    });\n    t.test('Test deleteSynonymsFromDb', function (st) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const _postgres = { query: sinon_1.stub().returns(Promise.resolve()) };\n            const listSynonyms = '(\"ERBB2\",\"NEU\",\"HER-2\",\"CD340\",\"HER2\")';\n            const result = yield controllerSynonyms_1.deleteSynonymsFromDb({ _postgres, listSynonyms })\n                .catch((err) => {\n                st.notOk(err, 'Function should not error');\n            });\n            st.assert(_postgres.query.calledTwice, 'Trigger postgres call twice');\n            st.end();\n        });\n    });\n    t.end();\n});\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29udHJvbGxlclN5bm9ueW1zLnNwZWMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvU3lub255bXMvY29udHJvbGxlclN5bm9ueW1zLnNwZWMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBLDZCQUE2QjtBQUU3QixpQ0FBNkI7QUFJN0IsMkJBQTJCO0FBRTNCLDZEQUEwSjtBQUcxSixJQUFJLENBQUMsNkJBQTZCLEVBQUUsQ0FBQyxDQUFPLEVBQUUsRUFBRTtJQUU5QyxDQUFDLENBQUMsSUFBSSxDQUFDLGlFQUFpRSxFQUFFLFVBQWdCLEVBQVE7O1lBRWhHLE1BQU0sU0FBUyxHQUFRLEVBQUUsS0FBSyxFQUFFLFlBQUksRUFBRSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsT0FBTyxFQUFFLENBQUMsRUFBRSxDQUFDO1lBQ3BFLE1BQU0sT0FBTyxHQUFHLEVBQUUsTUFBTSxFQUFFLE9BQU8sRUFBRSxDQUFDO1lBQ3BDLE1BQU0sSUFBSSxHQUFRLElBQUksR0FBRyxFQUFFLENBQUM7WUFDNUIsTUFBTSxZQUFZLEdBQUcsWUFBSSxDQUFDLElBQUksRUFBRSxVQUFVLENBQUMsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7WUFDMUQsTUFBTSxPQUFPLEdBQUcsWUFBSSxFQUFFLENBQUM7WUFDdkIsTUFBTSxVQUFVLEdBQUcsQ0FBQztvQkFDbEIsZUFBZSxFQUFDLGtEQUFrRDtpQkFDbkUsQ0FBQyxDQUFDO1lBQ0gsTUFBTSxxQkFBcUIsR0FBRyxZQUFJLEVBQUUsQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDO1lBRTFFLE1BQU0sa0JBQWtCLEdBQUcsQ0FBQyxPQUFPLEVBQUMsS0FBSyxFQUFDLE9BQU8sRUFBQyxPQUFPLEVBQUMsTUFBTSxDQUFDLENBQUM7WUFDbEUsTUFBTSxTQUFTLEdBQUcsWUFBSSxFQUFFLENBQUMsT0FBTyxDQUFDLE9BQU8s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",
    "static": true,
    "longname": "/Users/alexanderbrinkmann/Documents/Repositories/metis/dist/Synonyms/controllerSynonyms.spec.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 97,
    "kind": "test",
    "name": "test4",
    "testId": 4,
    "memberof": "dist/Synonyms/controllerSynonyms.spec.js",
    "testDepth": 0,
    "static": true,
    "longname": "dist/Synonyms/controllerSynonyms.spec.js~test4",
    "access": null,
    "description": "Testing Synonyms controller",
    "lineNumber": 15
  },
  {
    "__docId__": 98,
    "kind": "testFile",
    "name": "dist/Synonyms/synonyms-schema.spec.js",
    "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst test = require(\"tape\");\nconst Ajv = require(\"ajv\");\nconst fs = require(\"fs\");\n//--------------------------\nconst schemas = [\n    JSON.parse(fs.readFileSync('./schemas/synonyms-is-valid.json', 'utf8'))\n];\nconst ajv = new Ajv({ allErrors: true, verbose: true, schemas });\ntest('The synonyms schema is valid', (t) => {\n    const schema = ajv.getSchema('synonyms-is-valid.json');\n    t.ok(schema !== undefined, 'Synonyms schema loads');\n    t.end();\n});\ntest('Symbol is required', (t) => {\n    const schema = ajv.getSchema('synonyms-is-valid.json');\n    const json = {};\n    const valid = schema(json);\n    t.notOk(valid, 'Object without symbol is not valid payload');\n    t.ok(schema.errors, 'There are errors');\n    if (schema.errors) {\n        t.equals(schema.errors[0]['message'], 'should have required property \\'symbol\\'', 'Correct error message');\n    }\n    t.end();\n});\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3lub255bXMtc2NoZW1hLnNwZWMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvU3lub255bXMvc3lub255bXMtc2NoZW1hLnNwZWMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSw2QkFBNkI7QUFFN0IsMkJBQTJCO0FBQzNCLHlCQUF5QjtBQUV6Qiw0QkFBNEI7QUFFNUIsTUFBTSxPQUFPLEdBQVU7SUFDckIsSUFBSSxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsWUFBWSxDQUFDLGtDQUFrQyxFQUFFLE1BQU0sQ0FBQyxDQUFDO0NBQ3hFLENBQUM7QUFFRixNQUFNLEdBQUcsR0FBRyxJQUFJLEdBQUcsQ0FBQyxFQUFFLFNBQVMsRUFBRSxJQUFJLEVBQUUsT0FBTyxFQUFFLElBQUksRUFBRSxPQUFPLEVBQUUsQ0FBQyxDQUFDO0FBRWpFLElBQUksQ0FBQyw4QkFBOEIsRUFBRSxDQUFDLENBQU8sRUFBRSxFQUFFO0lBQy9DLE1BQU0sTUFBTSxHQUFHLEdBQUcsQ0FBQyxTQUFTLENBQUMsd0JBQXdCLENBQUMsQ0FBQztJQUN2RCxDQUFDLENBQUMsRUFBRSxDQUFDLE1BQU0sS0FBSyxTQUFTLEVBQUUsdUJBQXVCLENBQUMsQ0FBQztJQUNwRCxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUM7QUFDVixDQUFDLENBQUMsQ0FBQztBQUVILElBQUksQ0FBQyxvQkFBb0IsRUFBRSxDQUFDLENBQU8sRUFBRSxFQUFFO0lBQ3JDLE1BQU0sTUFBTSxHQUFHLEdBQUcsQ0FBQyxTQUFTLENBQUMsd0JBQXdCLENBQUMsQ0FBQztJQUN2RCxNQUFNLElBQUksR0FBRyxFQUFHLENBQUM7SUFDakIsTUFBTSxLQUFLLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQzNCLENBQUMsQ0FBQyxLQUFLLENBQUMsS0FBSyxFQUFFLDRDQUE0QyxDQUFDLENBQUM7SUFDN0QsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxNQUFNLENBQUMsTUFBTSxFQUFFLGtCQUFrQixDQUFDLENBQUM7SUFDeEMsRUFBRSxDQUFDLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7UUFDbEIsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxFQUFFLDBDQUEwQyxFQUFFLHVCQUF1QixDQUFDLENBQUM7SUFDN0csQ0FBQztJQUNELENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQztBQUNWLENBQUMsQ0FBQyxDQUFDIn0=",
    "static": true,
    "longname": "/Users/alexanderbrinkmann/Documents/Repositories/metis/dist/Synonyms/synonyms-schema.spec.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 99,
    "kind": "test",
    "name": "test5",
    "testId": 5,
    "memberof": "dist/Synonyms/synonyms-schema.spec.js",
    "testDepth": 0,
    "static": true,
    "longname": "dist/Synonyms/synonyms-schema.spec.js~test5",
    "access": null,
    "description": "The synonyms schema is valid",
    "lineNumber": 11
  },
  {
    "__docId__": 100,
    "kind": "test",
    "name": "test6",
    "testId": 6,
    "memberof": "dist/Synonyms/synonyms-schema.spec.js",
    "testDepth": 0,
    "static": true,
    "longname": "dist/Synonyms/synonyms-schema.spec.js~test6",
    "access": null,
    "description": "Symbol is required",
    "lineNumber": 16
  },
  {
    "__docId__": 101,
    "kind": "testFile",
    "name": "dist/Synonyms/synonyms.spec.js",
    "content": "\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst test = require(\"tape\");\nconst sinon_1 = require(\"sinon\");\nconst synonyms_1 = require(\"./synonyms\");\n//-------------------------------\ntest('Testing getSynonym service', (t) => {\n    t.test('Returns synonyms', function (st) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const symbol = 'ERBB2';\n            const synonymsResult = [['ERBB2', 'NEU', 'HER-2', 'CD340', 'HER2']];\n            const requestResponse = {\n                'response': {\n                    'docs': [{\n                            'symbol': 'ERBB2',\n                            'name': 'erb-b2 receptor tyrosine kinase 2',\n                            'alias_symbol': [\n                                'NEU',\n                                'HER-2',\n                                'CD340',\n                                'HER2'\n                            ],\n                            'alias_name': [\n                                'neuro/glioblastoma derived oncogene homolog',\n                                'human epidermal growth factor receptor 2'\n                            ]\n                        }]\n                }\n            };\n            const _request = sinon_1.stub().returns(Promise.resolve(requestResponse));\n            st.equals(typeof synonyms_1.synonyms, 'function', 'The module exports a function called synonyms');\n            const result = yield synonyms_1.synonyms({ payload: { symbol }, _request })\n                .then(function (data) {\n                //console.log('got data', data);\n                return data;\n            }).catch((err) => {\n                console.log('API call failed...' + err);\n                st.notOk(err, 'There is an error');\n            });\n            st.assert(result instanceof Object, 'Returns an object');\n            st.deepEquals(result, synonymsResult, 'The final result is equal to the expected result');\n            st.end();\n        });\n    });\n    //----------------------------\n    t.test('Returns synonyms via alias', function (st) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const symbol = 'HER2';\n            const synonymsResult = [['ERBB2', 'NEU', 'HER-2', 'CD340', 'HER2']];\n            const requestResponse = {\n                'response': {\n                    'docs': [{\n                            'symbol': 'ERBB2',\n                            'name': 'erb-b2 receptor tyrosine kinase 2',\n                            'alias_symbol': [\n                                'NEU',\n                                'HER-2',\n                                'CD340',\n                                'HER2'\n                            ],\n                            'alias_name': [\n                                'neuro/glioblastoma derived oncogene homolog',\n                                'human epidermal growth factor receptor 2'\n                            ]\n                        }]\n                }\n            };\n            const _request = sinon_1.stub().returns(Promise.resolve(requestResponse));\n            st.equals(typeof synonyms_1.synonyms, 'function', 'The module exports a function called synonyms');\n            const result = yield synonyms_1.synonyms({ payload: { symbol }, _request })\n                .then(function (data) {\n                //console.log('got data', data);\n                return data;\n            }).catch((err) => {\n                console.log('API call failed...' + err);\n                st.notOk(err, 'There is an error');\n            });\n            st.assert(result instanceof Object, 'Returns an object');\n            st.deepEquals(result, synonymsResult, 'The final result is equal to the expected result');\n            st.end();\n        });\n    });\n    t.test('Fail to find a synonym', function (st) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const symbol = 'zzzzyzzz';\n            const synonymsResult = [];\n            const requestResponse = {\n                'response': {\n                    'responseHeader': {\n                        'status': 0,\n                        'QTime': 1\n                    }\n                }\n            };\n            const _request = sinon_1.stub().returns(Promise.resolve(requestResponse));\n            st.equals(typeof synonyms_1.synonyms, 'function', 'The module exports a function called synonyms');\n            const result = yield synonyms_1.synonyms({ payload: { symbol }, _request })\n                .then(function (data) {\n                //console.log('got data', data);\n                return data;\n            }).catch((err) => {\n                console.log('API call failed...' + err);\n                st.notOk(err, 'There is an error');\n            });\n            st.assert(result instanceof Object, 'Returns an object');\n            st.deepEquals(result, synonymsResult, 'The final result is equal to the expected result');\n            st.end();\n        });\n    });\n    t.test('Returns allSynonyms', function (st) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const synonymsResult = [['ERBB2', 'NEU', 'HER-2', 'CD340', 'HER2'],\n                ['A1CF', 'ACF', 'ASP', 'ACF64', 'ACF65', 'APOBEC1CF']];\n            const requestResponse = {\n                'response': {\n                    'docs': [{\n                            'symbol': 'ERBB2',\n                            'name': 'alpha-1-B glycoprotein',\n                            'alias_symbol': [\n                                'NEU',\n                                'HER-2',\n                                'CD340',\n                                'HER2'\n                            ],\n                            'alias_name': [\n                                'neuro/glioblastoma derived oncogene homolog',\n                                'human epidermal growth factor receptor 2'\n                            ]\n                        },\n                        {\n                            'symbol': 'A1CF',\n                            'name': 'erb-b2 receptor tyrosine kinase 2',\n                            'alias_symbol': [\n                                'ACF',\n                                'ASP',\n                                'ACF64',\n                                'ACF65',\n                                'APOBEC1CF'\n                            ],\n                            'location': '10q11.23'\n                        }]\n                }\n            };\n            const _request = sinon_1.stub().returns(Promise.resolve(requestResponse));\n            st.equals(typeof synonyms_1.allSynonyms, 'function', 'The module exports a function called allSynonyms');\n            const result = yield synonyms_1.allSynonyms({ _request })\n                .then(function (data) {\n                //console.log('got data', data);\n                return data;\n            }).catch((err) => {\n                console.log('API call failed...' + err);\n                st.notOk(err, 'There is an error');\n            });\n            st.assert(result instanceof Object, 'Returns an object');\n            st.deepEquals(result, synonymsResult, 'The final result is equal to the expected result');\n            st.end();\n        });\n    });\n    t.end();\n});\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3lub255bXMuc3BlYy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9TeW5vbnltcy9zeW5vbnltcy5zcGVjLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQSw2QkFBNkI7QUFFN0IsaUNBQTZCO0FBRTdCLHlDQUFtRDtBQUVuRCxpQ0FBaUM7QUFFakMsSUFBSSxDQUFDLDRCQUE0QixFQUFFLENBQUMsQ0FBTyxFQUFFLEVBQUU7SUFDN0MsQ0FBQyxDQUFDLElBQUksQ0FBQyxrQkFBa0IsRUFBRSxVQUFnQixFQUFROztZQUVqRCxNQUFNLE1BQU0sR0FBVyxPQUFPLENBQUM7WUFDL0IsTUFBTSxjQUFjLEdBQUcsQ0FBRSxDQUFDLE9BQU8sRUFBRSxLQUFLLEVBQUUsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLENBQUMsQ0FBRSxDQUFDO1lBRXRFLE1BQU0sZUFBZSxHQUFRO2dCQUMzQixVQUFVLEVBQUU7b0JBQ1YsTUFBTSxFQUFFLENBQUM7NEJBQ1AsUUFBUSxFQUFFLE9BQU87NEJBQ2pCLE1BQU0sRUFBRSxtQ0FBbUM7NEJBQzNDLGNBQWMsRUFBRTtnQ0FDZCxLQUFLO2dDQUNMLE9BQU87Z0NBQ1AsT0FBTztnQ0FDUCxNQUFNOzZCQUNQOzRCQUNELFlBQVksRUFBRTtnQ0FDWiw2Q0FBNkM7Z0NBQzdDLDBDQUEwQzs2QkFDM0M7eUJBQ0YsQ0FBQztpQkFDSDthQUNGLENBQUM7WUFFRixNQUFNLFFBQVEsR0FBUSxZQUFJLEVBQUUsQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxlQUFlLENBQUMsQ0FBQyxDQUFDO1lBRXZFLEVBQUUsQ0FBQyxNQUFNLENBQUMsT0FBTyxtQkFBUSxFQUFFLFVBQVUsRUFBRSwrQ0FBK0MsQ0FBQyxDQUFDO1lBRXhGLE1BQU0sTUFBTSxHQUFHLE1BQU0sbUJBQVEsQ0FBQyxFQUFFLE9BQU8sRUFBRSxFQUFFLE1BQU0sRUFBRSxFQUFFLFFBQVEsRUFBRSxDQUFDO2lCQUM3RCxJQUFJLENBQUMsVUFBVSxJQUFTO2dCQUN2QixnQ0FBZ0M7Z0JBQ2hDLE1BQU0sQ0FBQyxJQUFJLENBQUM7WUFDZCxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxHQUFRLEVBQUUsRUFBRTtnQkFDcEIsT0FBTyxDQUFDLEdBQUcsQ0FBQyxvQkFBb0IsR0FBRyxHQUFHLENBQUMsQ0FBQztnQkFDeEMsRUFBRSxDQUFDLEtBQUssQ0FBQyxHQUFHLEVBQUUsbUJBQW1CLENBQUMsQ0FBQztZQUNyQyxDQUFDLENBQUMsQ0FBQztZQUNMLEVBQUUsQ0FBQyxNQUFNLENBQUMsTUFBTSxZQUFZLE1BQU0sRUFBRSxtQkFBbUIsQ0FBQyxDQUFDO1lBQ3pELEVBQUUsQ0FBQyxVQUFVLENBQUMsTUFBTSxFQUFFLGNBQWMsRUFBRSxrREFBa0QsQ0FBQyxDQUFDO1lBQzFGLEVBQUUsQ0FBQyxHQUFHLEVBQUUsQ0FBQztRQUNYLENBQUM7S0FBQSxDQUFDLENBQUM7SUFFSCw4QkFBOEI7SUFFOUIsQ0FBQyxDQUFDLElBQUksQ0FBQyw0QkFBNEIsRUFBRSxVQUFnQixFQUFROztZQUUzRCxNQUFNLE1BQU0sR0FBVyxNQUFNLENBQUM7WUFDOUIsTUFBTSxjQUFjLEdBQUcsQ0FBRSxDQUFDLE9BQU8sRUFBRSxLQUFLLEVBQUUsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLENBQUMsQ0FBRSxDQUFDO1lBRXRFLE1BQU0sZUFBZSxHQUFRO2dCQUMzQixVQUFVLEVBQUU7b0JBQ1YsTUFBTSxFQUFFLENBQUM7NEJBQ1AsUUFBUSxFQUFFLE9BQU87NEJBQ2pCLE1BQU0sRUFBRSxtQ0FBbUM7NEJBQzNDLGNBQWMsRUFBRTtnQ0FDZCxLQUFLO2dDQUNMLE9BQU87Z0NBQ1AsT0FBTztnQ0FDUCxNQUFNOzZCQUNQOzRCQUNELFlBQVksRUFBRTtnQ0FDWiw2Q0FBNkM7Z0NBQzdDLDBDQUEwQzs2QkFDM0M7eUJBQ0YsQ0FBQztpQkFDSDthQUNGLENBQUM7WUFFRixNQUFNLFFBQVEsR0FBUSxZQUFJLEVBQUUsQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxlQUFlLENBQUMsQ0FBQyxDQUFDO1lBRXZFLEVBQUUsQ0FBQyxNQUFNLENBQUMsT0FBTyxtQkFBUSxFQUFFLFVBQVUsRUFBRSwrQ0FBK0MsQ0FBQyxDQUFDO1lBRXhGLE1BQU0sTUFBTSxHQUFHLE1BQU0sbUJBQVEsQ0FBQyxFQUFFLE9BQU8sRUFBRSxFQUFFLE1BQU0sRUFBRSxFQUFFLFFBQVEsRUFBRSxDQUFDO2lCQUM3RCxJQUFJLENBQUMsVUFBVSxJQUFTO2dCQUN2QixnQ0FBZ0M7Z0JBQ2hDLE1BQU0sQ0FBQyxJQUFJLENBQUM7WUFDZCxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxHQUFRLEVBQUUsRUFBRTtnQkFDcEIsT0FBTyxDQUFDLEdBQUcsQ0FBQyxvQkFBb0IsR0FBRyxHQUFHLENBQUMsQ0FBQztnQkFDeEMsRUFBRSxDQUFDLEtBQUssQ0FBQyxHQUFHLEVBQUUsbUJBQW1CLENBQUMsQ0FBQztZQUNyQyxDQUFDLENBQUMsQ0FBQztZQUNMLEVBQUUsQ0FBQyxNQUFNLENBQUMsTUFBTSxZQUFZLE1BQU0sRUFBRSxtQkFBbUIsQ0FBQyxDQUFDO1lBQ3pELEVBQUUsQ0FBQyxVQUFVLENBQUMsTUFBTSxFQUFFLGNBQWMsRUFBRSxrREFBa0QsQ0FBQyxDQUFDO1lBQzFGLEVBQUUsQ0FBQyxHQUFHLEVBQUUsQ0FBQztRQUNYLENBQUM7S0FBQSxDQUFDLENBQUM7SUFFSCxDQUFDLENBQUMsSUFBSSxDQUFDLHdCQUF3QixFQUFFLFVBQWdCLEVBQVE7O1lBRXZELE1BQU0sTUFBTSxHQUFXLFVBQVUsQ0FBQztZQUNsQyxNQUFNLGNBQWMsR0FBVSxFQUFFLENBQUM7WUFFakMsTUFBTSxlQUFlLEdBQVE7Z0JBQzNCLFVBQVUsRUFBRTtvQkFDVixnQkFBZ0IsRUFBRTt3QkFDaEIsUUFBUSxFQUFFLENBQUM7d0JBQ1gsT0FBTyxFQUFFLENBQUM7cUJBQ1g7aUJBQ0Y7YUFDRixDQUFDO1lBRUYsTUFBTSxRQUFRLEdBQVEsWUFBSSxFQUFFLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsZUFBZSxDQUFDLENBQUMsQ0FBQztZQUV2RSxFQUFFLENBQUMsTUFBTSxDQUFDLE9BQU8sbUJBQVEsRUFBRSxVQUFVLEVBQUUsK0NBQStDLENBQUMsQ0FBQztZQUV4RixNQUFNLE1BQU0sR0FBRyxNQUFNLG1CQUFRLENBQUMsRUFBRSxPQUFPLEVBQUUsRUFBRSxNQUFNLEVBQUUsRUFBRSxRQUFRLEVBQUUsQ0FBQztpQkFDN0QsSUFBSSxDQUFDLFVBQVUsSUFBUztnQkFDdkIsZ0NBQWdDO2dCQUNoQyxNQUFNLENBQUMsSUFBSSxDQUFDO1lBQ2QsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBUSxFQUFFLEVBQUU7Z0JBQ3BCLE9BQU8sQ0FBQyxHQUFHLENBQUMsb0JBQW9CLEdBQUcsR0FBRyxDQUFDLENBQUM7Z0JBQ3hDLEVBQUUsQ0FBQyxLQUFLLENBQUMsR0FBRyxFQUFFLG1CQUFtQixDQUFDLENBQUM7WUFDckMsQ0FBQyxDQUFDLENBQUM7WUFDTCxFQUFFLENBQUMsTUFBTSxDQUFDLE1BQU0sWUFBWSxNQUFNLEVBQUUsbUJBQW1CLENBQUMsQ0FBQztZQUN6RCxFQUFFLENBQUMsVUFBVSxDQUFDLE1BQU0sRUFBRSxjQUFjLEVBQUUsa0RBQWtELENBQUMsQ0FBQztZQUMxRixFQUFFLENBQUMsR0FBRyxFQUFFLENBQUM7UUFDWCxDQUFDO0tBQUEsQ0FBQyxDQUFDO0lBRUgsQ0FBQyxDQUFDLElBQUksQ0FBQyxxQkFBcUIsRUFBRSxVQUFnQixFQUFROztZQUNwRCxNQUFNLGNBQWMsR0FBRyxDQUFDLENBQUMsT0FBTyxFQUFFLEtBQUssRUFBRSxPQUFPLEVBQUUsT0FBTyxFQUFFLE1BQU0sQ0FBQztnQkFDMUMsQ0FBQyxNQUFNLEVBQUMsS0FBSyxFQUFDLEtBQUssRUFBQyxPQUFPLEVBQUMsT0FBTyxFQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUM7WUFFMUUsTUFBTSxlQUFlLEdBQVE7Z0JBQzNCLFVBQVUsRUFBRTtvQkFDVixNQUFNLEVBQUUsQ0FBQzs0QkFDUCxRQUFRLEVBQUUsT0FBTzs0QkFDakIsTUFBTSxFQUFFLHdCQUF3Qjs0QkFDaEMsY0FBYyxFQUFFO2dDQUNkLEtBQUs7Z0NBQ0wsT0FBTztnQ0FDUCxPQUFPO2dDQUNQLE1BQU07NkJBQ1A7NEJBQ0QsWUFBWSxFQUFFO2dDQUNaLDZDQUE2QztnQ0FDN0MsMENBQTBDOzZCQUMzQzt5QkFDRjt3QkFDRDs0QkFDRSxRQUFRLEVBQUUsTUFBTTs0QkFDaEIsTUFBTSxFQUFFLG1DQUFtQzs0QkFDM0MsY0FBYyxFQUFFO2dDQUNkLEtBQUs7Z0NBQ0wsS0FBSztnQ0FDTCxPQUFPO2dDQUNQLE9BQU87Z0NBQ1AsV0FBVzs2QkFDWjs0QkFDRCxVQUFVLEVBQUUsVUFBVTt5QkFDdkIsQ0FBQztpQkFDSDthQUNGLENBQUM7WUFFRixNQUFNLFFBQVEsR0FBUSxZQUFJLEVBQUUsQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxlQUFlLENBQUMsQ0FBQyxDQUFDO1lBRXZFLEVBQUUsQ0FBQyxNQUFNLENBQUMsT0FBTyxzQkFBVyxFQUFFLFVBQVUsRUFBRSxrREFBa0QsQ0FBQyxDQUFDO1lBRTlGLE1BQU0sTUFBTSxHQUFHLE1BQU0sc0JBQVcsQ0FBQyxFQUFFLFFBQVEsRUFBRSxDQUFDO2lCQUMzQyxJQUFJLENBQUMsVUFBVSxJQUFTO2dCQUN2QixnQ0FBZ0M7Z0JBQ2hDLE1BQU0sQ0FBQyxJQUFJLENBQUM7WUFDZCxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxHQUFRLEVBQUUsRUFBRTtnQkFDcEIsT0FBTyxDQUFDLEdBQUcsQ0FBQyxvQkFBb0IsR0FBRyxHQUFHLENBQUMsQ0FBQztnQkFDeEMsRUFBRSxDQUFDLEtBQUssQ0FBQyxHQUFHLEVBQUUsbUJBQW1CLENBQUMsQ0FBQztZQUNyQyxDQUFDLENBQUMsQ0FBQztZQUNMLEVBQUUsQ0FBQyxNQUFNLENBQUMsTUFBTSxZQUFZLE1BQU0sRUFBRSxtQkFBbUIsQ0FBQyxDQUFDO1lBQ3pELEVBQUUsQ0FBQyxVQUFVLENBQUMsTUFBTSxFQUFFLGNBQWMsRUFBRSxrREFBa0QsQ0FBQyxDQUFDO1lBQzFGLEVBQUUsQ0FBQyxHQUFHLEVBQUUsQ0FBQztRQUNYLENBQUM7S0FBQSxDQUFDLENBQUM7SUFFSCxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUM7QUFDVixDQUFDLENBQUMsQ0FBQyJ9",
    "static": true,
    "longname": "/Users/alexanderbrinkmann/Documents/Repositories/metis/dist/Synonyms/synonyms.spec.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 102,
    "kind": "test",
    "name": "test7",
    "testId": 7,
    "memberof": "dist/Synonyms/synonyms.spec.js",
    "testDepth": 0,
    "static": true,
    "longname": "dist/Synonyms/synonyms.spec.js~test7",
    "access": null,
    "description": "Testing getSynonym service",
    "lineNumber": 15
  },
  {
    "__docId__": 103,
    "kind": "testFile",
    "name": "dist/service.spec.js",
    "content": "\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst test = require(\"tape\");\nconst sinon_1 = require(\"sinon\");\nconst service_1 = require(\"./service\");\ntest('Testing basic service', (t) => {\n    function _test() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const _pack = { version: '1', name: 'metis' };\n            const _iris = { request: sinon_1.stub(), register: sinon_1.stub().returns(Promise.resolve()) };\n            const _irisSetup = sinon_1.stub().returns(Promise.resolve(_iris));\n            const irisConfig = { url: 'a', exchange: 'b', namespace: 'c' };\n            const _config = { get: sinon_1.stub().returns(irisConfig) };\n            t.equals(typeof service_1.default, 'function', 'Service exports a function');\n            const setupResult = service_1.default({ _pack, _irisSetup, _config });\n            t.ok(setupResult instanceof Promise, 'Service setup must return a promise');\n            yield setupResult\n                .then(() => {\n                t.ok(true, 'Yeah, service setup does not blow up');\n            })\n                .catch(() => {\n                t.notOk(true, 'Setup should not blow up at this point');\n            });\n            t.ok(_iris.register.called, 'Add from iris is called');\n            let addCall = _iris.register.getCall(0);\n            t.equal(addCall.args[0].pattern, 'status.metis', 'The service exposes a status handle');\n            const statusImp = addCall.args[0].handler;\n            const impResultP = statusImp({});\n            t.ok(impResultP instanceof Promise, 'The implementation of status returns a promise');\n            yield impResultP\n                .then((result) => {\n                t.deepEqual(_pack, result, 'The implementation returns what we expect');\n                t.ok(true, 'Implementation does not blow up');\n            })\n                .catch(() => {\n                t.notOk(true, 'Implementation should not blow up');\n            });\n            addCall = _iris.register.getCall(1);\n            t.equal(addCall.args[0].pattern, 'action.annotate.get', 'The service exposes an annotate handle');\n            addCall = _iris.register.getCall(2);\n            t.equal(addCall.args[0].pattern, 'action.synonyms.get', 'The service exposes a getSynonymsHandler');\n            addCall = _iris.register.getCall(3);\n            t.equal(addCall.args[0].pattern, 'action.synonyms.populate', 'The service exposes a populateSynonymsHandler');\n            addCall = _iris.register.getCall(4);\n            t.equal(addCall.args[0].pattern, 'action.synonyms.all', 'The service exposes a populateSynonymsHandler');\n        });\n    }\n    _test()\n        .then(() => t.end())\n        .catch(console.error);\n});\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VydmljZS5zcGVjLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL3NlcnZpY2Uuc3BlYy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUEsNkJBQTZCO0FBRTdCLGlDQUE2QjtBQUM3Qix1Q0FBNkI7QUFFN0IsSUFBSSxDQUFDLHVCQUF1QixFQUFFLENBQUMsQ0FBTyxFQUFFLEVBQUU7SUFDeEM7O1lBRUUsTUFBTSxLQUFLLEdBQUcsRUFBRSxPQUFPLEVBQUUsR0FBRyxFQUFFLElBQUksRUFBRSxPQUFPLEVBQUUsQ0FBQztZQUM5QyxNQUFNLEtBQUssR0FBRyxFQUFFLE9BQU8sRUFBRSxZQUFJLEVBQVMsRUFBRSxRQUFRLEVBQUUsWUFBSSxFQUFFLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxPQUFPLEVBQUUsQ0FBUSxFQUFFLENBQUM7WUFDN0YsTUFBTSxVQUFVLEdBQUcsWUFBSSxFQUFFLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztZQUMxRCxNQUFNLFVBQVUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsUUFBUSxFQUFFLEdBQUcsRUFBRSxTQUFTLEVBQUUsR0FBRyxFQUFFLENBQUM7WUFDL0QsTUFBTSxPQUFPLEdBQUcsRUFBRSxHQUFHLEVBQUUsWUFBSSxFQUFFLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQyxFQUFTLENBQUM7WUFFM0QsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxPQUFPLGlCQUFJLEVBQUUsVUFBVSxFQUFFLDRCQUE0QixDQUFDLENBQUM7WUFFaEUsTUFBTSxXQUFXLEdBQUcsaUJBQUksQ0FBQyxFQUFFLEtBQUssRUFBRSxVQUFVLEVBQUUsT0FBTyxFQUFFLENBQUMsQ0FBQztZQUV6RCxDQUFDLENBQUMsRUFBRSxDQUFDLFdBQVcsWUFBWSxPQUFPLEVBQUUscUNBQXFDLENBQUMsQ0FBQztZQUU1RSxNQUFNLFdBQVc7aUJBQ2QsSUFBSSxDQUFDLEdBQUcsRUFBRTtnQkFDVCxDQUFDLENBQUMsRUFBRSxDQUFDLElBQUksRUFBRSxzQ0FBc0MsQ0FBQyxDQUFDO1lBQ3JELENBQUMsQ0FBQztpQkFDRCxLQUFLLENBQUMsR0FBRyxFQUFFO2dCQUNWLENBQUMsQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLHdDQUF3QyxDQUFDLENBQUM7WUFDMUQsQ0FBQyxDQUFDLENBQUM7WUFFTCxDQUFDLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsTUFBTSxFQUFFLHlCQUF5QixDQUFDLENBQUM7WUFFdkQsSUFBSSxPQUFPLEdBQUcsS0FBSyxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFFeEMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sRUFBRSxjQUFjLEVBQUUscUNBQXFDLENBQUMsQ0FBQztZQUV4RixNQUFNLFNBQVMsR0FBRyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQztZQUMxQyxNQUFNLFVBQVUsR0FBRyxTQUFTLENBQUMsRUFBRSxDQUFDLENBQUM7WUFFakMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxVQUFVLFlBQVksT0FBTyxFQUFFLGdEQUFnRCxDQUFDLENBQUM7WUFFdEYsTUFBTSxVQUFVO2lCQUNiLElBQUksQ0FBQyxDQUFDLE1BQVcsRUFBRSxFQUFFO2dCQUNwQixDQUFDLENBQUMsU0FBUyxDQUFDLEtBQUssRUFBRSxNQUFNLEVBQUUsMkNBQTJDLENBQUMsQ0FBQztnQkFDeEUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxJQUFJLEVBQUUsaUNBQWlDLENBQUMsQ0FBQztZQUNoRCxDQUFDLENBQUM7aUJBQ0QsS0FBSyxDQUFDLEdBQUcsRUFBRTtnQkFDVixDQUFDLENBQUMsS0FBSyxDQUFDLElBQUksRUFBRSxtQ0FBbUMsQ0FBQyxDQUFDO1lBQ3JELENBQUMsQ0FBQyxDQUFDO1lBRUwsT0FBTyxHQUFHLEtBQUssQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ3BDLENBQUMsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLEVBQUUscUJBQXFCLEVBQUUsd0NBQXdDLENBQUMsQ0FBQztZQUVsRyxPQUFPLEdBQUcsS0FBSyxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDcEMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sRUFBRSxxQkFBcUIsRUFBRSwwQ0FBMEMsQ0FBQyxDQUFDO1lBRXBHLE9BQU8sR0FBRyxLQUFLLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNwQyxDQUFDLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxFQUFFLDBCQUEwQixFQUFFLCtDQUErQyxDQUFDLENBQUM7WUFFOUcsT0FBTyxHQUFHLEtBQUssQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ3BDLENBQUMsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLEVBQUUscUJBQXFCLEVBQUUsK0NBQStDLENBQUMsQ0FBQztRQUUzRyxDQUFDO0tBQUE7SUFFRCxLQUFLLEVBQUU7U0FDSixJQUFJLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDO1NBQ25CLEtBQUssQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDMUIsQ0FBQyxDQUFDLENBQUMifQ==",
    "static": true,
    "longname": "/Users/alexanderbrinkmann/Documents/Repositories/metis/dist/service.spec.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 104,
    "kind": "test",
    "name": "test8",
    "testId": 8,
    "memberof": "dist/service.spec.js",
    "testDepth": 0,
    "static": true,
    "longname": "dist/service.spec.js~test8",
    "access": null,
    "description": "Testing basic service",
    "lineNumber": 14
  }
]